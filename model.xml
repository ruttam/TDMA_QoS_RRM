<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Place global declarations here.

// --------------------------------------------------------------------------------------------
// GLOBAL CONSTANTS
// Provides supported system capacity, number of active users, time units, frame information
// --------------------------------------------------------------------------------------------

// In this model time is measured in us, it can be further atomized changing the
// unit value, e.g. to 10, 100, 1000
const int unit = 1;    // time unit ratio wrt 1 us

clock frame_clk;    // frame clock timer

const int number_BS = 2;    // number of Base Stations
typedef int [0, number_BS - 1] BSid_t;

const int number_UE = 10;    // number of User Equipment
typedef int [0, number_UE - 1] UEid_t;

const int number_profiles = 5;    // number of UE profiles
typedef int [0, number_profiles - 1] profileId_t;

const profileId_t initial = 0;        // Initial connected mode
const profileId_t Listen_Only = 1;    // Listen-Only
const profileId_t sRTa = 2;           // Sporadic Real-Time Audio
const profileId_t RTa = 3;            // Real-Time Audio
const profileId_t HqRTa = 4;          // High-Quality Real-Time Audio

const int latency[profileId_t] = {-1, 2500, 70, 40, 20};    // latency requirements of each type of profiles

// --------------------------------------------------------------------------------------------
// INITIAL CASE
// Static and equal slot size for all nodes
// A beacon slot of static size in the end of the frame
// --------------------------------------------------------------------------------------------

const int MCS = 3;    // MCS index

const int channel_bandwidth = 40;    // MHz

const int data_rate = 60;    // Mbit/s

const int GI = 400;    // us

const int audio_quality = 48;    // kbits/s

const int bit_depth = 16;    // bits

int number_GIs = 2;    // initial number of GI spaces

int GI_size;

profileId_t static_profile[UEid_t] = {3, 3, 3, 3, 3, 3, 3, 1, 1, 1};

typedef int [0, number_UE] slotID_t;

int owner[slotID_t] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

int slot_start[slotID_t] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};    // start times of dedicated TCH slots for the nodes in current frame + RACH

int slot_size[slotID_t] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};    // sizes of dedicated TCH slots for the nodes in current frame + RACH (ms * unit)

// --------------------------------------------------------------------------------------------
// Initial variables of the system
// --------------------------------------------------------------------------------------------

profileId_t profile[UEid_t] = {4, 1, 2, 3, 4, 2, 0, 1, 2, 3};    // initial profiles of the UEs - can be negotiated with the BS

const int frame_size = latency[RTa] * 1000 * unit;    // initial frame size (us * unit)

int UCCH_size = 500;    // mini-slot: size of a slot for transmitting meta data

// --------------------------------------------------------------------------------------------
// UE INITIAL
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan started[UEid_t];    // UE start signal

const int offset_used = -1;    // offset ID used (-1: using default)

const int offsets[2][UEid_t] =
{
    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
    {10, 20, 5, 0, 10, 40, 7, 15, 30, 0}
};

// VARIABLES ----------------------------------------------------------------------------------

int start_offsets[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // default offset of UE start signal

int BS_assignment[UEid_t] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};    // initial association with the BS

// FUNCTIONS ----------------------------------------------------------------------------------

int getBS(UEid_t id)
{
    return BS_assignment[id];
}

void setOffset()    // setting offset values from possible variations in offsets
{
    if(offset_used != -1)
        for(i: UEid_t) start_offsets[i] = offsets[offset_used][i] * unit;
}

// --------------------------------------------------------------------------------------------
// UE CONNECT
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan connected[UEid_t];    // UE connected signal

broadcast chan disconnected[UEid_t];    // UE disconnected signal

broadcast chan failed[UEid_t];    // UE signal for failed latency requirements

broadcast chan RACH;    // UE signal to BS through the random access channel in order to connect

const int disconnect_timeout = 5000 * 1000 * unit;    // timeout for disconnect in us

// VARIABLES ----------------------------------------------------------------------------------

// connection channel stability
int connection_channel_stability[UEid_t][2] =
{
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75}
};

int RACH_slot = number_UE;

int RACH_start = 0;    // start time of random access channel in the current frame

int RACH_size = 0;  // size of random access channel slots (us * unit)

int RACH_id = -1;    // UE id which sends RACH signal in the current RACH slot

// --------------------------------------------------------------------------------------------
// LISTEN_ONLY
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan listen[UEid_t];    // UE to set Listen-Only mode signal

broadcast chan BCH[BSid_t];    // broadcast channel

broadcast chan sleep[UEid_t];    // UE signal for RF module to sleep

broadcast chan wake_up[UEid_t];    // UE signal for RF module to wake-up

broadcast chan UCCH[UEid_t];    // Up-Link control channel

// VARIABLES ----------------------------------------------------------------------------------

// int BCH_duration = 5;    // initial BCH transmission duration

// initial channel interference probability
int channel_interference_probability[UEid_t][2] =
{
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75}
};

// --------------------------------------------------------------------------------------------
// TODO
//
// Channel interference probability is transmission success probability. It must be calculated to
// depend on the UE distance from the BS and used MCS - the error correction level
// --------------------------------------------------------------------------------------------

bool ACK[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // BS acknowledge of the initial UL resource request from the UE

int sleep_time[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // RRM (Radio Resource Manager) calculated sleep time for UE after receiving UL ACKs

// --------------------------------------------------------------------------------------------
// STREAM
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan stream[UEid_t];    // UE signal to start audio streaming

broadcast chan sample[UEid_t];    // UE signal to DSP to start audio sampling

broadcast chan stop_sample[UEid_t];    // UE signal to DSP to stop audio sampling (in case of mode changes)

broadcast chan sample_ready[UEid_t];    // UE signal from DSP that a new audio sample is ready loaded in the memory

broadcast chan UTCH[UEid_t];    // up-link UE signal to BS transmitting audio data

// VARIABLES ----------------------------------------------------------------------------------

int samples_ready[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // audio samples ready to be read from memory

int samples_lost[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // audio samples that were lost because of moving relevant sample window

// FUNCTIONS ----------------------------------------------------------------------------------

int getLatency(UEid_t id)
{
    return latency[static_profile[id]];
}

//double dsp_to_qca(){
//    return (frame_size/1000 * audio_data_rate)/uart_speed;
//}

// --------------------------------------------------------------------------------------------
// QUEUE
// --------------------------------------------------------------------------------------------

typedef struct {
    int prior;    // priority identification (depending on QoS and CQI)
    UEid_t id;    // UE's ID
} Node_t;

typedef struct {
    int front;
    int rear;
    int size;
    Node_t queue[UEid_t];
} Queue_t;

bool isEmpty(Queue_t q){
    return q.size &lt; 0;
}

bool isFull(Queue_t q)
{
    return q.size == number_UE;
}

int getSize(Queue_t q)
{
    return q.size;
}

Node_t getFirst(Queue_t q)
{
    return q.queue[q.front];
}

Node_t getLast(Queue_t q)
{
    return q.queue[q.rear];
}

int insert(Node_t value, Queue_t &amp;q)    // add a node according to its priority
{
    int i = 0;
    bool found = false;

    if(!isFull(q)){
        if(isEmpty(q))
        {
            q.queue[++q.size] = value;
            q.front = q.rear = 0;
        }
        else
        {
            for(i = q.size-1; i &gt;= 0; i--)
            {
                if(value.prior &gt; q.queue[i].prior &amp;&amp; !found)
                {
                    q.queue[i+1] = q.queue[i];
                    found = true;
                }
            }
            q.queue[i] = value;
            q.size++;
        }
        return 0;
    }
    else
    {
        // Queue is full
        return -1;
    }
}

int enqueue(Node_t value, Queue_t &amp;q)    // add a node at the end of the queue
{
    if(q.size &lt; number_UE)
    {
        if(isEmpty(q))
        {
            q.queue[0] = value;
            q.front = q.rear = 0;
            q.size = 1;
        }
        else if(q.rear == number_UE - 1)
        {
            q.queue[0] = value;
            q.rear = 0;
            q.size++;
        }
        else
        {
            q.queue[q.rear + 1] = value;
            q.rear++;
            q.size++;
        }
        return 0;
    }
    else
    {
        // Queue is full
        return -1;
    }
}

int pop(Queue_t q)
{
    if(isEmpty(q))
    {
        // Queue is empty
        return -1;
    }
    else
    {
        Node_t value = getLast(q);
        q.size--;
        q.rear--;
        return value.id;
    }
}

int dequeue(Queue_t q)
{

    if(isEmpty(q))
    {
        // Queue is empty
        return -1;
    }
    else
    {
        Node_t value = getFirst(q);
        q.size--;
        q.front++;
        return value.id;
    }
}

// --------------------------------------------------------------------------------------------
// BASE STATION
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan schedule[BSid_t];    // BS signal to execute radio resource scheduling

broadcast chan scheduled[BSid_t];    // RRM signal to BS that scheduling is done

const int channel_switch = 250 * unit;    // frequency change latency

// VARIABLES ----------------------------------------------------------------------------------

int broadcast_channel[BSid_t] = {2000, 3500};    // BCH transmission channel frequencies (kHz)

int retransmission_channel[BSid_t] = {2400, 5000};    // BCH retransmission channel frequencies (kHz)

bool retransmission[BSid_t] = {false, false};

int number_slots = 0;    //  UTCHs, UCCHs and RACH

Queue_t priority_queue[BSid_t] =    // Queue of active devices with profiles RTa, hqRTa and sRTA
{
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}},
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}}
};

Queue_t request_queue[BSid_t] =    // Queue of active devices in connected and Listen-Only modes
{
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}},
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}}
};

bool active_UE[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // identification of UE that are active

bool listen_only_UE[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // identification of UE that are in Listen-Only mode

bool connected_UE[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // identification of UE that are in initial connected mode

int UE_CQI[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // channel quality indications of all active UE

// FUNCTIONS ----------------------------------------------------------------------------------

int getActive()
{
    int counter = 0;
    for(i: UEid_t)
    {
        if(active_UE[i])
            counter++;
    }
    return counter;
}

int getListeners()
{
    int counter = 0;
    for(i: UEid_t)
    {
        if(listen_only_UE[i])
            counter++;
    }
    return counter;
}

int getConnected()
{
    int counter = 0;
    for(i: UEid_t)
    {
        if(listen_only_UE[i])
            counter++;
    }
    return counter;
}

// Note: max capacity of BCH headers is 40 Bytes

int BCH_meta_bits;
int BCH_slot_audio_bits;
int BCH_duration;
// frame-based sampling approach for the initial case
int getBCHDuration()    // in us
{
    int BCH_slot_meta_bits = 5 * 8;
    //                              in us
    BCH_meta_bits = (((512 * 1024)/frame_size/8) + 64) * 8;
    //                                                   in us
    BCH_slot_audio_bits = (audio_quality/1000) * frame_size + BCH_slot_meta_bits;
    return (BCH_meta_bits + (BCH_slot_meta_bits + BCH_slot_audio_bits) * getActive() + (BCH_slot_meta_bits + BCH_slot_audio_bits) * getListeners() + BCH_slot_meta_bits * getConnected())/data_rate;
}

int getULMetaDuration()    // in us
{
    return (20 * 8)/data_rate;
}

int getULAudioDuration()    // in us
{
    int UL_duration = ((audio_quality/1000) * frame_size + getULMetaDuration())/data_rate;
    return UL_duration;
}

int getRACHDuration()    // in us
{
    return (176 * 8)/data_rate;
}

void add_UE(BSid_t bs, UEid_t id)
{
    Node_t new_node = {-1, id};
    ACK[id] = true;
    if(profile[id] == initial)
    {
        connected_UE[id] = true;
    }
    else if(profile[id] == Listen_Only)
    {
        listen_only_UE[id] = true;
    }
    else
    {
        active_UE[id] = true;
        new_node.prior = profile[id];
        insert(new_node, priority_queue[bs]);
        return;
    }
    enqueue(new_node, request_queue[bs]);
}

</declaration>
	<template>
		<name>Scheduler</name>
		<parameter>BSid_t id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

bool done = false;    // Successful scheduling indication

int disconnect_UE = -1;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int scheduleRF()
{
    bool new_entrants = false;
    for(i: UEid_t)
    {
        if(ACK[i])
        {
            new_entrants = true;
        }
    }
    if(!done || new_entrants)
    {
    int j = 0;
    int BCH_end;
    int slot_count;    // BCH, UTCHs, UCCHs and RACH
    int start_time = 0;
    int transmission_duration = frame_size/2;
    int UL_duration = getULAudioDuration() * getActive() + getULMetaDuration() * (getListeners() + getConnected());

    BCH_end = channel_switch + getBCHDuration();
    RACH_size = getRACHDuration();
    number_slots = getActive() + getListeners() + 1;
    slot_count = 2 + number_slots;
    GI_size = (transmission_duration - (BCH_end + UL_duration + RACH_size))/slot_count;

    // GI verification
    if(GI_size &lt; GI)    // actual GI size must be &gt;= of GI required by MCS used
    {
        // drop Listen-Only node and re-evaluate
        for(i: UEid_t)
        {
            if(listen_only_UE[i])
            {
                disconnect_UE = i;
                return 0;
            }
        }
        // drop streaming node and re-evaluate, if no Listen-Only nodes available
        for(i: UEid_t)
        {
            if(active_UE[i])
            {
                disconnect_UE = i;
                return 0;
            }
        }
        disconnect_UE = -1;    // unschedulable - erroneous frame setup
    }

    // slot start calculation
    start_time = BCH_end + GI_size;
    for(i: UEid_t)
    {
        if(active_UE[i])
        {
            owner[j++] = i;
            slot_size[i] = getULAudioDuration();
            slot_start[i] = start_time;
            start_time = slot_start[i] + slot_size[i]  + GI_size;
        }
    }
    for(i: UEid_t)
    {
        if(listen_only_UE[i])
        {
            owner[j++] = i;
            slot_size[i] = getULMetaDuration();
            slot_start[i] = start_time;
            start_time = slot_start[i] + slot_size[i] + GI_size;
        }
    }
    for(i: UEid_t)
    {
        if(connected_UE[i])
        {
            owner[j++] = i;
            slot_size[i] = getULMetaDuration();
            slot_start[i] = start_time;
            start_time = slot_start[i] + slot_size[i] + GI_size;
        }
    }
    owner[j++] = number_UE;
    slot_size[number_UE] = RACH_size;
    slot_start[number_UE] = start_time;
    RACH_start = start_time;
    }
    return 1;
}

// --------------------------------------------------------------------------------------------
// TODO
// reset the ACK -- in the ACK enabled version
// --------------------------------------------------------------------------------------------
</declaration>
		<location id="id0" x="-841" y="-519" color="#ffffff">
			<name x="-851" y="-553">INITIAL</name>
		</location>
		<location id="id1" x="-841" y="-374">
			<name x="-926" y="-383">STARTED</name>
			<urgent/>
		</location>
		<location id="id2" x="-603" y="-247">
			<name x="-628" y="-230">FINISHED</name>
			<urgent/>
		</location>
		<location id="id3" x="-841" y="-247">
			<name x="-901" y="-230">RETRANSMISSION</name>
			<urgent/>
		</location>
		<location id="id4" x="-603" y="-425" color="#ffa500">
			<name x="-620" y="-459">RETRY</name>
			<urgent/>
		</location>
		<location id="id5" x="-782" y="-374" color="#ff0000">
			<name x="-817" y="-408">UNSCHEDULABLE</name>
			<urgent/>
		</location>
		<init ref="id0"/>
		<transition>
			<source ref="id5"/>
			<target ref="id1"/>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id5"/>
			<label kind="guard" x="-756" y="-374">disconnect_UE == -1</label>
			<nail x="-620" y="-374"/>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id1"/>
			<label kind="guard" x="-816" y="-468">disconnect_UE != -1</label>
			<label kind="synchronisation" x="-816" y="-451">disconnected[disconnect_UE]!</label>
			<nail x="-817" y="-425"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id4"/>
			<label kind="guard" x="-663" y="-340">done != 1</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="assignment" x="-748" y="-246">done = 1</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="guard" x="-952" y="-306">retransmission[id]</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="guard" x="-637" y="-561">done</label>
			<label kind="synchronisation" x="-637" y="-544">scheduled[id]!</label>
			<label kind="assignment" x="-637" y="-519">frame_clk = 0</label>
			<nail x="-552" y="-247"/>
			<nail x="-552" y="-519"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="guard" x="-790" y="-306">!retransmission[id]</label>
			<label kind="assignment" x="-790" y="-281">done = scheduleRF()</label>
			<nail x="-807" y="-281"/>
			<nail x="-629" y="-281"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-926" y="-459">schedule[id]?</label>
		</transition>
	</template>
	<template>
		<name>BaseStation</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // general urility timer

int slot = 0;    // slot counter during the frame execution

UEid_t current = 0;    // ID of current slot's owner (UE)
</declaration>
		<location id="id6" x="-842" y="-1012" color="#ffffff">
			<name x="-867" y="-1045">INITIAL</name>
			<urgent/>
		</location>
		<location id="id7" x="-383" y="-850">
			<name x="-366" y="-876">FRAME_READY</name>
			<label kind="invariant" x="-366" y="-859">x' == 0</label>
		</location>
		<location id="id8" x="-383" y="-723">
			<name x="-417" y="-706">SEND_BCH</name>
			<label kind="invariant" x="-417" y="-689">x' == 1 &amp;&amp;
frame_clk &lt;= BCH_duration</label>
		</location>
		<location id="id9" x="-841" y="-544">
			<name x="-824" y="-561">WAIT_UL</name>
			<label kind="invariant" x="-824" y="-544">x &lt;= slot_size[owner[slot]]</label>
		</location>
		<location id="id10" x="-842" y="-850">
			<urgent/>
		</location>
		<location id="id11" x="-1130" y="-408" color="#00ff00">
			<name x="-1155" y="-392">UL_ACK</name>
			<urgent/>
		</location>
		<location id="id12" x="-1028" y="-544" color="#00ffff">
			<name x="-1062" y="-527">UL_NACK</name>
			<urgent/>
		</location>
		<location id="id13" x="-1130" y="-544">
			<name x="-1224" y="-535">NEXT_SLOT</name>
			<urgent/>
		</location>
		<location id="id14" x="-842" y="-927">
			<name x="-927" y="-944">TRANSMIT</name>
			<urgent/>
		</location>
		<location id="id15" x="-502" y="-850" color="#ffff00">
			<name x="-544" y="-884">RETRANSMIT</name>
			<urgent/>
		</location>
		<location id="id16" x="-842" y="-723">
			<name x="-833" y="-766">GUARD</name>
			<label kind="invariant" x="-833" y="-748">x &lt;= GI_size</label>
		</location>
		<location id="id17" x="-680" y="-850">
			<name x="-731" y="-901">SWITCH_CHANNEL</name>
			<label kind="invariant" x="-731" y="-884">x &lt;= channel_switch</label>
		</location>
		<location id="id18" x="-841" y="-629">
			<label kind="invariant" x="-824" y="-637">frame_clk &lt;= slot_start[owner[slot]]</label>
		</location>
		<init ref="id6"/>
		<transition>
			<source ref="id18"/>
			<target ref="id9"/>
			<label kind="guard" x="-833" y="-603">frame_clk &gt;= slot_start[owner[slot]]</label>
			<label kind="assignment" x="-833" y="-586">x = 0</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id15"/>
			<label kind="guard" x="-663" y="-850">x &gt;= channel_switch</label>
			<label kind="assignment" x="-663" y="-833">x = 0</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id18"/>
			<label kind="guard" x="-833" y="-705">x &gt;= GI_size &amp;&amp;
slot &lt; number_slots</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-485" y="-850">schedule[id]!</label>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-468" y="-952">schedule[id]!</label>
			<nail x="-383" y="-927"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id17"/>
			<label kind="guard" x="-816" y="-850">retransmission[id]</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id14"/>
			<label kind="guard" x="-961" y="-893">!retransmission[id]</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id10"/>
			<label kind="guard" x="-978" y="-825">x &gt;= GI_size &amp;&amp;
slot &gt;= number_slots</label>
			<label kind="assignment" x="-1080" y="-808">x = 0,
retransmission[id] = !retransmission[id]</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id11"/>
			<label kind="guard" x="-832" y="-459">owner[slot] == RACH_slot</label>
			<label kind="synchronisation" x="-832" y="-442">RACH?</label>
			<label kind="assignment" x="-832" y="-425">current = RACH_id</label>
			<nail x="-841" y="-408"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id13"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id13"/>
			<label kind="assignment" x="-1257" y="-502">RACH_id = -1,
add_UE(id, current)</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id16"/>
			<label kind="assignment" x="-1122" y="-723">slot += 1,
x = 0</label>
			<nail x="-1131" y="-723"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id12"/>
			<label kind="guard" x="-1011" y="-569">x &gt;= slot_size[owner[slot]]</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-1011" y="-459">UTCH[current]?</label>
			<nail x="-917" y="-434"/>
			<nail x="-1096" y="-434"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-1036" y="-493">UCCH[current]?</label>
			<nail x="-943" y="-468"/>
			<nail x="-1104" y="-468"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id16"/>
			<label kind="guard" x="-562" y="-766">frame_clk &gt;= BCH_duration</label>
			<label kind="synchronisation" x="-562" y="-749">BCH[id]!</label>
			<label kind="assignment" x="-562" y="-723">slot = 0,
x = 0</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-375" y="-782">scheduled[id]?</label>
			<label kind="assignment" x="-375" y="-799">BCH_duration = getBCHDuration()</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id14"/>
		</transition>
	</template>
	<template>
		<name>UserListenOnly</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // latency timer
clock z;    // disconnect timer

bool dedicated_channel_set = false;    // 0 - false, 1 - true

int prob_failure;
int prob_success;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_failure = channel_interference_probability[id][0];
    prob_success = channel_interference_probability[id][1];
}</declaration>
		<location id="id19" x="-1836" y="-1495" color="#ffffff">
			<name x="-1879" y="-1478">INITIAL</name>
			<label kind="invariant" x="-1879" y="-1461">x' == 0 &amp;&amp;
z' == 0</label>
		</location>
		<location id="id20" x="-1199" y="-1495">
			<name x="-1318" y="-1487">BCH_RECEIVED</name>
			<label kind="invariant" x="-1318" y="-1470">z' == 0</label>
			<urgent/>
		</location>
		<location id="id21" x="-1199" y="-1725">
			<name x="-1233" y="-1776">META_DATA</name>
			<label kind="invariant" x="-1241" y="-1759">x &lt;= slot_start[id]</label>
		</location>
		<location id="id22" x="-1539" y="-1402">
			<name x="-1556" y="-1385">DL_NACK</name>
			<label kind="invariant" x="-1556" y="-1368">z' == 1</label>
			<urgent/>
		</location>
		<location id="id23" x="-1667" y="-1496">
			<name x="-1751" y="-1555">WAIT_BCH</name>
			<label kind="invariant" x="-1751" y="-1538">x &lt;= getLatency(id) &amp;&amp;
z &lt;= disconnect_timeout</label>
		</location>
		<location id="id24" x="-1666" y="-1402" color="#4e342e">
			<name x="-1683" y="-1385">FAIL</name>
			<urgent/>
		</location>
		<location id="id25" x="-1667" y="-1733" color="#4e342e">
			<name x="-1768" y="-1767">DISCONNECT</name>
			<urgent/>
		</location>
		<location id="id26" x="-1454" y="-1725">
			<name x="-1488" y="-1776">TRANSMIT</name>
			<label kind="invariant" x="-1505" y="-1759">x &lt;= slot_size[id]/2</label>
		</location>
		<branchpoint id="id27" x="-1454" y="-1666">
		</branchpoint>
		<init ref="id19"/>
		<transition>
			<source ref="id27"/>
			<target ref="id23"/>
			<label kind="synchronisation" x="-1445" y="-1623">UCCH[id]!</label>
			<label kind="assignment" x="-1445" y="-1589">dedicated_channel_set = 1</label>
			<label kind="probability" x="-1445" y="-1606">prob_success</label>
			<nail x="-1454" y="-1555"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id27"/>
			<label kind="guard" x="-1572" y="-1708">x &gt;= slot_size[id]/2</label>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id19"/>
			<label kind="assignment" x="-1828" y="-1733">z = 0,
x = 0</label>
			<nail x="-1835" y="-1732"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id23"/>
			<label kind="synchronisation" x="-1803" y="-1496">listen[id]?</label>
			<label kind="assignment" x="-1743" y="-1470">x = 0</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id21"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id26"/>
			<label kind="guard" x="-1386" y="-1725">x &gt;= slot_start[id]</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id23"/>
			<nail x="-1539" y="-1444"/>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id20"/>
			<label kind="guard" x="-1513" y="-1496">x &lt;= getLatency(id)</label>
			<label kind="synchronisation" x="-1513" y="-1513">BCH[BS_assignment[id]]?</label>
			<label kind="assignment" x="-1513" y="-1479">z = 0</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id22"/>
			<label kind="assignment" x="-1624" y="-1402">z = x</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id24"/>
			<label kind="guard" x="-1658" y="-1453">x &gt;= getLatency(id)</label>
			<label kind="synchronisation" x="-1658" y="-1436">failed[id]!</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id25"/>
			<label kind="guard" x="-1819" y="-1606">z &gt;= disconnect_timeout</label>
			<label kind="synchronisation" x="-1785" y="-1623">disconnected[id]!</label>
		</transition>
	</template>
	<template>
		<name>UserJoined</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // transmission timer
clock z;    // disconnect timer

int prob_success;
int prob_failure;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_failure = channel_interference_probability[id][0];
    prob_success = channel_interference_probability[id][1];
}

// --------------------------------------------------------------------------------------------
// TODO
// --------------------------------------------------------------------------------------------
</declaration>
		<location id="id28" x="246" y="552">
			<name x="170" y="544">STREAM</name>
		</location>
		<location id="id29" x="246" y="306">
			<urgent/>
		</location>
		<location id="id30" x="60" y="306" color="#ffffff">
			<name x="34" y="238">INITIAL</name>
			<label kind="invariant" x="34" y="255">x' == 0 &amp;&amp;
z' == 0</label>
		</location>
		<location id="id31" x="909" y="238">
			<name x="858" y="255">BCH_RECEIVED</name>
			<label kind="invariant" x="858" y="272">z' == 0 &amp;&amp;
x' == 1</label>
			<urgent/>
		</location>
		<location id="id32" x="909" y="127">
			<name x="867" y="76">META_DATA</name>
			<label kind="invariant" x="841" y="93">x &lt;= slot_start[id]</label>
		</location>
		<location id="id33" x="484" y="238">
			<name x="493" y="246">WAIT_BCH</name>
			<label kind="invariant" x="493" y="263">z' == 1 &amp;&amp;
x' == 0 &amp;&amp;
z &lt;= disconnect_timeout</label>
		</location>
		<location id="id34" x="484" y="501" color="#4e342e">
			<name x="383" y="509">DISCONNECT</name>
			<urgent/>
		</location>
		<location id="id35" x="688" y="127">
			<name x="654" y="76">TRANSMIT</name>
			<label kind="invariant" x="637" y="93">x &lt;= slot_size[id]/2</label>
		</location>
		<location id="id36" x="306" y="425">
			<name x="255" y="433">LISTEN</name>
		</location>
		<location id="id37" x="246" y="238">
			<name x="236" y="204">CONNECTED</name>
			<urgent/>
		</location>
		<branchpoint id="id38" x="484" y="127">
		</branchpoint>
		<init ref="id30"/>
		<transition>
			<source ref="id37"/>
			<target ref="id33"/>
			<label kind="assignment" x="340" y="238">z = 0</label>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id37"/>
			<label kind="guard" x="127" y="263">profile[id] == initial</label>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="323" y="484">disconnected[id]?</label>
			<nail x="306" y="501"/>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id36"/>
			<label kind="guard" x="314" y="348">profile[id] == Listen_Only ||
profile[id] == sRTa</label>
			<label kind="synchronisation" x="314" y="382">listen[id]!</label>
			<nail x="306" y="306"/>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="263" y="535">disconnected[id]?</label>
			<nail x="484" y="552"/>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id28"/>
			<label kind="guard" x="119" y="416">profile[id] == RTa ||
profile[id] == HqRTa</label>
			<label kind="synchronisation" x="178" y="450">stream[id]!</label>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id33"/>
			<label kind="synchronisation" x="493" y="178">UCCH[id]!</label>
			<label kind="probability" x="493" y="161">prob_success</label>
		</transition>
		<transition>
			<source ref="id35"/>
			<target ref="id38"/>
			<label kind="guard" x="518" y="127">x &gt;= slot_size[id]/2</label>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id30"/>
			<label kind="assignment" x="68" y="535">z = 0,
x = 0</label>
			<nail x="510" y="501"/>
			<nail x="510" y="578"/>
			<nail x="59" y="578"/>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id29"/>
			<label kind="synchronisation" x="93" y="305">connected[id]?</label>
			<label kind="assignment" x="153" y="331">x = 0</label>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id35"/>
			<label kind="guard" x="739" y="127">x &gt;= slot_start[id]</label>
			<label kind="assignment" x="739" y="144">x = 0</label>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="637" y="212">BCH[BS_assignment[id]]?</label>
			<label kind="assignment" x="637" y="238">z = 0</label>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id34"/>
			<label kind="guard" x="493" y="408">z &gt;= disconnect_timeout</label>
			<label kind="synchronisation" x="493" y="425">disconnected[id]!</label>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id32"/>
			<label kind="assignment" x="875" y="170">x = 0</label>
		</transition>
	</template>
	<template>
		<name>UserStates</name>
		<parameter>int id, int start_offset</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock offset;    // start offset timer

int mode = 0;    // 1 - Listen Only, 2 - Streaming

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int getOffset()
{
    if(start_offset == -1) {
        setOffset();
        return start_offsets[id];
    }
    else
    {
        return start_offset;
    }
    return 0;
}</declaration>
		<location id="id39" x="-15130" y="-15266" color="#ffffff">
			<name x="-15138" y="-15300">INIT</name>
			<urgent/>
		</location>
		<location id="id40" x="-15130" y="-14942">
			<name x="-15240" y="-14943">LISTEN_ONLY</name>
		</location>
		<location id="id41" x="-14832" y="-14942">
			<name x="-14815" y="-14951">STREAMING</name>
		</location>
		<location id="id42" x="-14985" y="-15028" color="#4e342e">
			<name x="-15011" y="-15062">FAILED</name>
			<urgent/>
		</location>
		<location id="id43" x="-14832" y="-15266" color="#4e342e">
			<name x="-14815" y="-15275">DISCONNECTED</name>
			<urgent/>
		</location>
		<location id="id44" x="-15130" y="-15096">
			<name x="-15240" y="-15113">CONNECTING</name>
			<label kind="invariant" x="-15223" y="-15096">offset' == 0</label>
		</location>
		<location id="id45" x="-15130" y="-15189">
			<name x="-15172" y="-15198">ON</name>
			<label kind="invariant" x="-15113" y="-15206">offset' == 1 &amp;&amp;
offset &lt;= start_offset</label>
		</location>
		<init ref="id39"/>
		<transition>
			<source ref="id45"/>
			<target ref="id44"/>
			<label kind="guard" x="-15121" y="-15155">offset &gt;= start_offset</label>
			<label kind="synchronisation" x="-15121" y="-15138">started[id]!</label>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id43"/>
			<label kind="synchronisation" x="-15045" y="-15096">disconnected[id]?</label>
			<nail x="-14875" y="-15096"/>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id40"/>
			<label kind="synchronisation" x="-15232" y="-15028">connected[id]?</label>
			<label kind="assignment" x="-15198" y="-15011">mode = 1</label>
		</transition>
		<transition>
			<source ref="id42"/>
			<target ref="id40"/>
			<label kind="guard" x="-15096" y="-14994">mode == 1</label>
			<nail x="-15028" y="-14977"/>
			<nail x="-15104" y="-14977"/>
		</transition>
		<transition>
			<source ref="id40"/>
			<target ref="id43"/>
			<label kind="synchronisation" x="-15266" y="-15342">disconnected[id]?</label>
			<nail x="-15266" y="-14943"/>
			<nail x="-15266" y="-15316"/>
			<nail x="-14832" y="-15316"/>
		</transition>
		<transition>
			<source ref="id43"/>
			<target ref="id39"/>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id43"/>
			<label kind="synchronisation" x="-14824" y="-15079">disconnected[id]?</label>
		</transition>
		<transition>
			<source ref="id42"/>
			<target ref="id41"/>
			<label kind="guard" x="-14943" y="-14994">mode == 2</label>
			<nail x="-14951" y="-14977"/>
			<nail x="-14866" y="-14977"/>
		</transition>
		<transition>
			<source ref="id40"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-15087" y="-15045">failed[id]?</label>
			<nail x="-15104" y="-15028"/>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-14926" y="-15045">failed[id]?</label>
			<nail x="-14858" y="-15028"/>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id40"/>
			<label kind="synchronisation" x="-15036" y="-14909">stop_sample[id]?</label>
			<nail x="-14832" y="-14892"/>
			<nail x="-15130" y="-14892"/>
		</transition>
		<transition>
			<source ref="id40"/>
			<target ref="id41"/>
			<label kind="synchronisation" x="-15028" y="-14960">stream[id]?</label>
			<label kind="assignment" x="-15028" y="-14943">mode = 2</label>
		</transition>
		<transition>
			<source ref="id39"/>
			<target ref="id45"/>
			<label kind="assignment" x="-15121" y="-15257">offset = 0,
start_offset = getOffset()</label>
		</transition>
	</template>
	<template>
		<name>UserConnect</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int number_channels = 10;    // number of hard-coded channel frequencies to scan through

const int channels[number_channels] = {1500, 1800, 2000, 2200, 2300, 2400, 3100, 3500, 4200, 5000};    // channel frequencies (kHz) to scan for BS down-link reception

const int channel_stability_latency = 1 * unit;    // time to test channel stability before connecting to the BS

const int number_retries = 10;    // number of allowed retries of channel scanning before going to the INITIAL state

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // general usage timer

int i = 0;    // channel scan counter
int j = 0;    // re-try scan counter

bool found = false;

BSid_t bs;

int prob_stable;
int prob_unstable;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_unstable = connection_channel_stability[id][0];
    prob_stable = connection_channel_stability[id][1];
}

bool checkChannel(int ch_id)
{
    for(k: BSid_t)
    {
        if(broadcast_channel[k] == channels[ch_id])
        {
            BS_assignment[id] = k;
            bs = k;
            return true;
        }
        if(retransmission_channel[k] == channels[ch_id])
        {
            BS_assignment[id] = k;
            bs = k;
            return true;
        }
    }
    return false;
}

// --------------------------------------------------------------------------------------------
// TODO
// Channel stability should be dependent on the system topology - distance from the UE to the BS
// --------------------------------------------------------------------------------------------

</declaration>
		<location id="id46" x="-3238" y="-3128" color="#ffffff">
			<name x="-3255" y="-3162">INITIAL</name>
		</location>
		<location id="id47" x="-3238" y="-2839">
			<name x="-3221" y="-2856">TESTING_CHANNEL</name>
			<label kind="invariant" x="-3221" y="-2839">x &lt;= channel_stability_latency</label>
		</location>
		<location id="id48" x="-3238" y="-3000">
			<name x="-3229" y="-3026">SCANNING</name>
			<urgent/>
		</location>
		<location id="id49" x="-2754" y="-3128">
			<name x="-2788" y="-3161">CONNECTED</name>
			<urgent/>
		</location>
		<location id="id50" x="-2957" y="-2678">
			<name x="-3000" y="-2729">WAIT_BCH</name>
			<label kind="invariant" x="-3034" y="-2712">x &lt;= disconnect_timeout</label>
		</location>
		<location id="id51" x="-2957" y="-2533">
			<name x="-2992" y="-2516">TRANSMIT</name>
			<label kind="invariant" x="-2983" y="-2499">x &lt;= RACH_size/2</label>
		</location>
		<location id="id52" x="-2753" y="-2678">
			<name x="-2736" y="-2686">BCH_RECEIVED</name>
			<urgent/>
		</location>
		<location id="id53" x="-2753" y="-2533">
			<label kind="invariant" x="-2737" y="-2541">frame_clk &lt;= RACH_start</label>
		</location>
		<location id="id54" x="-3238" y="-2941">
			<urgent/>
		</location>
		<branchpoint id="id55" x="-3238" y="-2678">
		</branchpoint>
		<init ref="id46"/>
		<transition>
			<source ref="id48"/>
			<target ref="id54"/>
			<label kind="assignment" x="-3230" y="-2992">found = checkChannel(i),
i++</label>
		</transition>
		<transition>
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="guard" x="-3145" y="-2584">x &gt;= RACH_size/2 ||
RACH_id != -1</label>
			<label kind="assignment" x="-3145" y="-2550">x = 0</label>
			<nail x="-3017" y="-2533"/>
			<nail x="-3017" y="-2635"/>
		</transition>
		<transition>
			<source ref="id53"/>
			<target ref="id51"/>
			<label kind="guard" x="-2924" y="-2533">frame_clk &gt;= RACH_start</label>
			<label kind="assignment" x="-2796" y="-2516">x = 0</label>
		</transition>
		<transition>
			<source ref="id50"/>
			<target ref="id52"/>
			<label kind="guard" x="-2932" y="-2678">x &lt;= disconnect_timeout</label>
			<label kind="synchronisation" x="-2872" y="-2703">BCH[bs]?</label>
			<nail x="-2949" y="-2678"/>
		</transition>
		<transition>
			<source ref="id50"/>
			<target ref="id46"/>
			<label kind="guard" x="-2949" y="-3068">x &gt;= disconnect_timeout</label>
			<label kind="synchronisation" x="-2949" y="-3085">disconnected[id]!</label>
			<nail x="-2958" y="-3102"/>
			<nail x="-3204" y="-3102"/>
		</transition>
		<transition>
			<source ref="id52"/>
			<target ref="id49"/>
			<label kind="guard" x="-2745" y="-2898">ACK[id] == 1</label>
		</transition>
		<transition>
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="guard" x="-2949" y="-2618">RACH_id == -1</label>
			<label kind="synchronisation" x="-2949" y="-2601">RACH!</label>
			<label kind="assignment" x="-2949" y="-2584">RACH_id = id,
x = 0</label>
		</transition>
		<transition>
			<source ref="id52"/>
			<target ref="id53"/>
			<label kind="guard" x="-2745" y="-2618">ACK[id] == 0</label>
		</transition>
		<transition>
			<source ref="id49"/>
			<target ref="id46"/>
			<label kind="synchronisation" x="-2890" y="-3153">connected[id]!</label>
		</transition>
		<transition>
			<source ref="id54"/>
			<target ref="id48"/>
			<label kind="guard" x="-3451" y="-3000">found == 0 &amp;&amp;
i &gt;= number_channels &amp;&amp;
j &lt; number_retries</label>
			<label kind="assignment" x="-3451" y="-2941">i = 0,
j++</label>
			<nail x="-3459" y="-2941"/>
			<nail x="-3459" y="-3000"/>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id46"/>
			<label kind="guard" x="-3425" y="-3128">j &gt;= number_retries</label>
			<label kind="synchronisation" x="-3408" y="-3111">disconnected[id]!</label>
			<label kind="assignment" x="-3340" y="-3094">i = 0,
j = 0</label>
			<nail x="-3298" y="-3026"/>
			<nail x="-3298" y="-3128"/>
		</transition>
		<transition>
			<source ref="id54"/>
			<target ref="id48"/>
			<label kind="guard" x="-3051" y="-2983">found == 0 &amp;&amp;
i &lt; number_channels</label>
			<nail x="-3060" y="-2941"/>
			<nail x="-3059" y="-3000"/>
		</transition>
		<transition>
			<source ref="id54"/>
			<target ref="id47"/>
			<label kind="guard" x="-3230" y="-2932">found == 1</label>
			<label kind="assignment" x="-3230" y="-2915">x = 0,
bs = BS_assignment[id]</label>
		</transition>
		<transition>
			<source ref="id55"/>
			<target ref="id50"/>
			<label kind="assignment" x="-3162" y="-2677">i = 0,
j = 0,
x = 0</label>
			<label kind="probability" x="-3162" y="-2703">prob_stable</label>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id55"/>
			<label kind="guard" x="-3229" y="-2788">x &gt;= channel_stability_latency</label>
			<label kind="assignment" x="-3229" y="-2771">getProbability()</label>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id48"/>
			<label kind="synchronisation" x="-3230" y="-3085">started[id]?</label>
			<label kind="assignment" x="-3230" y="-3068">i = 0,
j = 0</label>
		</transition>
	</template>
	<template>
		<name>UserStream</name>
		<parameter>int id, int dma_latency</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // DMA delay timer
clock y;    // general usage timer

int transmission_latency;    // latency of data transmission: MCS speed / number of samples

int disconnect_timeout;    // time of no DL received before disconnecting (e.g., 5 sec)

int qca_latency;

// packet preparation time: QCA + DMA latencies
// can use samples prepared from last successful transmission to (slot start time - preparation time)</declaration>
		<location id="id56" x="-1309" y="-935" color="#ffffff">
			<name x="-1334" y="-969">INITIAL</name>
		</location>
		<location id="id57" x="-1156" y="-638">
			<name x="-1241" y="-638">WAIT_BCH</name>
			<label kind="invariant" x="-1215" y="-620">y' == 1</label>
		</location>
		<location id="id58" x="-1020" y="-578" color="#4e342e">
			<name x="-1003" y="-587">FAILED</name>
			<urgent/>
		</location>
		<location id="id59" x="-1504" y="-935" color="#4e342e">
			<name x="-1615" y="-943">DISCONNECT</name>
			<label kind="invariant" x="-1572" y="-926">y' == 0</label>
			<urgent/>
		</location>
		<location id="id60" x="-1156" y="-935">
			<label kind="invariant" x="-1198" y="-977">y &lt;= slot_start[id]</label>
		</location>
		<location id="id61" x="-994" y="-935">
			<name x="-977" y="-960">LOAD_FROM_MEM</name>
			<label kind="invariant" x="-977" y="-943">x &lt;= dma_latency</label>
		</location>
		<location id="id62" x="-841" y="-1020">
			<name x="-892" y="-1054">WAIT_SAMPLE</name>
		</location>
		<location id="id63" x="-1156" y="-748">
			<name x="-1249" y="-765">TRANSMIT</name>
			<label kind="invariant" x="-1343" y="-748">x &lt;= transmission_latency</label>
		</location>
		<location id="id64" x="-1156" y="-536">
			<name x="-1207" y="-519">BCH_RECEIVED</name>
			<urgent/>
		</location>
		<location id="id65" x="-1156" y="-824">
			<name x="-1283" y="-841">QCA_PROCESS</name>
			<label kind="invariant" x="-1283" y="-824">y &lt;= qca_latency</label>
		</location>
		<init ref="id56"/>
		<transition>
			<source ref="id64"/>
			<target ref="id60"/>
			<label kind="guard" x="-1428" y="-535">!retransmission[getBS(id)]</label>
			<nail x="-1640" y="-535"/>
			<nail x="-1640" y="-977"/>
			<nail x="-1181" y="-977"/>
		</transition>
		<transition>
			<source ref="id65"/>
			<target ref="id63"/>
			<label kind="guard" x="-1147" y="-807">y &gt;= qca_latency</label>
			<label kind="assignment" x="-1147" y="-790">x = 0</label>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-1326" y="-595">BCH[BS_assignment[id]]?</label>
		</transition>
		<transition>
			<source ref="id64"/>
			<target ref="id63"/>
			<label kind="guard" x="-1088" y="-535">retransmission[getBS(id)]</label>
			<nail x="-926" y="-536"/>
			<nail x="-926" y="-748"/>
		</transition>
		<transition>
			<source ref="id63"/>
			<target ref="id57"/>
			<label kind="guard" x="-1317" y="-705">x &gt;= transmission_latency</label>
			<label kind="synchronisation" x="-1224" y="-722">UTCH[id]!</label>
		</transition>
		<transition>
			<source ref="id62"/>
			<target ref="id65"/>
			<label kind="guard" x="-952" y="-824">y &gt;= slot_start[id]</label>
			<label kind="assignment" x="-884" y="-807">y = 0</label>
			<nail x="-841" y="-824"/>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id65"/>
			<label kind="guard" x="-1266" y="-884">y &gt;= slot_start[id]</label>
			<label kind="assignment" x="-1190" y="-867">y = 0</label>
		</transition>
		<transition>
			<source ref="id61"/>
			<target ref="id60"/>
			<label kind="guard" x="-1105" y="-901">x &gt; dma_latency</label>
			<nail x="-994" y="-875"/>
			<nail x="-1105" y="-875"/>
		</transition>
		<transition>
			<source ref="id62"/>
			<target ref="id61"/>
			<label kind="synchronisation" x="-994" y="-1003">sample_ready[id]?</label>
			<nail x="-875" y="-977"/>
			<nail x="-994" y="-977"/>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id62"/>
			<label kind="guard" x="-1156" y="-1062">samples_ready[id] == 0 &amp;&amp;
y &lt; slot_start[id]</label>
			<nail x="-1156" y="-1020"/>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id61"/>
			<label kind="guard" x="-1130" y="-960">y &lt; slot_start[id]</label>
			<label kind="assignment" x="-1130" y="-935">x = 0</label>
		</transition>
		<transition>
			<source ref="id59"/>
			<target ref="id56"/>
			<label kind="synchronisation" x="-1462" y="-960">disconnected[id]!</label>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id59"/>
			<label kind="guard" x="-1504" y="-637">y &gt; disconnect_timeout</label>
			<label kind="assignment" x="-1504" y="-620">y = 0</label>
			<nail x="-1504" y="-637"/>
		</transition>
		<transition>
			<source ref="id58"/>
			<target ref="id57"/>
			<label kind="synchronisation" x="-1105" y="-595">failed[id]!</label>
			<nail x="-1113" y="-578"/>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id58"/>
			<label kind="guard" x="-1011" y="-638">y &gt; getLatency(id) &amp;&amp;
y &lt;= disconnect_timeout</label>
			<nail x="-1020" y="-638"/>
		</transition>
		<transition>
			<source ref="id56"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-1266" y="-960">stream[id]?</label>
			<label kind="assignment" x="-1266" y="-935">x = 0,
y = 0</label>
		</transition>
	</template>
	<template>
		<name>UserSample</name>
		<parameter>int id, double audio_quality, double bit_depth</parameter>
		<declaration>// id: UE identification number
// audio_quality: audio sampling rate (kHz or kb/s)
// bit_depth: bits per sample

// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // sampling timer

int codec_latency = 10;    // codec processing delay, depends on MCS

int dma_latency = 1;    // DMA access and transfer latency, depends on bit depth

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int getSampleTime()
{
    // if audio quality is in bit rate (kbps)
    double sample_rate = audio_quality/bit_depth;    // kHz = 1000 * samples/s
    // if audio quality is in sample rate (kHz)
    double time_per_sample = 1/(sample_rate * 1000 * 1000 * unit);    // us * unit
    int result = fint(time_per_sample);
    return result;
}

// calculate number of samples
// choose default MCS to get data rate (Mbps) that a radio transmits in</declaration>
		<location id="id66" x="-662" y="-654">
			<name x="-688" y="-722">SAMPLE</name>
			<label kind="invariant" x="-688" y="-705">x' == 1 &amp;&amp;
x &lt;= getSampleTime()</label>
		</location>
		<location id="id67" x="-416" y="-654">
			<name x="-484" y="-705">PROCESS_CODEC</name>
			<label kind="invariant" x="-476" y="-688">x &lt;= codec_latency</label>
		</location>
		<location id="id68" x="-892" y="-654" color="#ffffff">
			<name x="-918" y="-705">INITIAL</name>
			<label kind="invariant" x="-918" y="-688">x' == 0</label>
		</location>
		<location id="id69" x="-416" y="-569">
			<name x="-399" y="-578">LOAD_TO_MEM</name>
			<label kind="invariant" x="-399" y="-561">x &lt;= dma_latency</label>
		</location>
		<location id="id70" x="-892" y="-569">
			<name x="-986" y="-578">STOPPING</name>
			<urgent/>
		</location>
		<init ref="id68"/>
		<transition>
			<source ref="id66"/>
			<target ref="id70"/>
			<label kind="synchronisation" x="-824" y="-518">disconnected[id]?</label>
			<nail x="-663" y="-518"/>
			<nail x="-892" y="-518"/>
		</transition>
		<transition>
			<source ref="id66"/>
			<target ref="id70"/>
			<label kind="synchronisation" x="-850" y="-569">stop_sample[id]?</label>
			<nail x="-697" y="-569"/>
		</transition>
		<transition>
			<source ref="id69"/>
			<target ref="id66"/>
			<label kind="guard" x="-629" y="-552">x &gt;= dma_latency</label>
			<label kind="synchronisation" x="-629" y="-569">sample_ready[id]!</label>
			<label kind="assignment" x="-629" y="-535">samples_ready[id] += 1,
x = 0</label>
			<nail x="-637" y="-569"/>
		</transition>
		<transition>
			<source ref="id67"/>
			<target ref="id69"/>
			<label kind="guard" x="-408" y="-637">x &gt;= codec_latency</label>
			<label kind="assignment" x="-408" y="-620">x = 0</label>
		</transition>
		<transition>
			<source ref="id70"/>
			<target ref="id68"/>
			<label kind="assignment" x="-926" y="-620">x = 0</label>
		</transition>
		<transition>
			<source ref="id68"/>
			<target ref="id66"/>
			<label kind="synchronisation" x="-824" y="-680">sample[id]?</label>
			<label kind="assignment" x="-824" y="-654">x = 0</label>
		</transition>
		<transition>
			<source ref="id66"/>
			<target ref="id67"/>
			<label kind="guard" x="-620" y="-654">x &gt;= getSampleTime()</label>
			<label kind="assignment" x="-620" y="-637">x = 0</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
usr_1 = UserStates(0, 5000);
usr_1c = UserConnect(0);
usr_1j = UserJoined(0);
usr_1lt = UserListenOnly(0);
usr_1s = UserStream(0, 1);
usr_1sm = UserSample(0, 48, 16);

bs_1 = BaseStation(0);
bs_1s = Scheduler(0);
// List one or more processes to be composed into a system.
system bs_1, bs_1s, usr_1, usr_1c, usr_1j, usr_1lt;
//, usr_1s, usr_1sm,
    </system>
	<queries>
		<query>
			<formula>A[] not bs_1s.UNSCHEDULABLE</formula>
			<comment>Frame must always be schedulable.</comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.RETRY</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.RETRANSMISSION</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.FINISHED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.STARTED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.NEXT_SLOT</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.UL_NACK</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.UL_ACK</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.WAIT_UL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.GUARD</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.SEND_BCH</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.FRAME_READY</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.RETRANSMIT</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.SWITCH_CHANNEL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.TRANSMIT</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1lt.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.BCH_RECEIVED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.WAIT_BCH</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.TESTING_CHANNEL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.SCANNING</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.INIT</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.CONNECTING</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.DISCONNECTED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.LISTEN_ONLY</formula>
			<comment></comment>
		</query>
	</queries>
</nta>
