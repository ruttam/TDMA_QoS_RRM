<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Place global declarations here.

// GLOBAL CONSTANTS ---------------------------------------------------------------------------
// Provides supported system capacity, number of active users, time units, frame information
// --------------------------------------------------------------------------------------------

// In this model time is measured in us, it can be further atomized changing the
// unit value, e.g. to 10, 100, 1000
const int unit = 1;    // time unit ratio wrt 1 us

const int number_BS = 2;    // number of Base Stations
typedef int [0, number_BS - 1] BSid_t;

clock frame_clk[BSid_t];    // frame clock timer

const int number_UE = 10;    // number of User Equipment
typedef int [0, number_UE - 1] UEid_t;

const int number_profiles = 5;    // number of UE profiles
typedef int [0, number_profiles - 1] profileId_t;

const profileId_t initial = 0;        // Initial connected mode
const profileId_t Listen_Only = 1;    // Listen-Only
const profileId_t sRTa = 2;           // Sporadic Real-Time Audio
const profileId_t RTa = 3;            // Real-Time Audio
const profileId_t HqRTa = 4;          // High-Quality Real-Time Audio

typedef int[-(1&lt;&lt;23),(1&lt;&lt;23)-1] int24_t;
const int latency[profileId_t] = {-1, 2500, 70, 40, 20};    // latency requirements of each type of profiles

// const int audio_quality[profileId_t] = {-1, 32, 32, 48, 192};    // audio quality requirements (in kbits/s) of each type of profiles

// GLOBAL VARIABLES ---------------------------------------------------------------------------

profileId_t profile[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // current profiles of the UEs

// int MCS[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // MCS index for every UE

int channel_bandwidth[BSid_t] = {40, 20};    // MHz

int24_t frame_size[BSid_t] = {latency[RTa] * 1000 * unit, latency[RTa] * 1000 * unit};    // initial frame size (us * unit)

int data_rate[BSid_t] = {60, 60};    // initial data transmission rate (in Mbit/s)

int GI[BSid_t] = {400, 400};    // required GI size according to the MCS used (in us)

int number_GI[BSid_t] = {2, 2};    // initial number of GI spaces  -- UNUSED

int GI_size[BSid_t] = {0, 0};    // actual GI size of the current frame (in us)

typedef int [0, number_UE] slotID_t;

int owner[BSid_t][slotID_t] = {
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

int slot_start[BSid_t][slotID_t] = {    // start times of dedicated TCH slots for the nodes in current frame + RACH
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

int slot_size[BSid_t][slotID_t] = {    // sizes of dedicated TCH slots for the nodes in current frame + RACH (ms * unit)
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

int24_t slot_data[BSid_t][slotID_t] = {    // data sizes of dedicated TCH slots in current frame + RACH (in bits)
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

// --------------------------------------------------------------------------------------------
// INITIAL CASE
// Static and equal slot size for all nodes
// A beacon slot of static size in the end of the frame
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

const int MCS = 3;    // MCS index

const int audio_quality = 48;    // kbits/s

const profileId_t static_profile[UEid_t] = {3, 3, 3, 3, 3, 3, 3, 1, 1, 1};    // profiles of the UEs - can be negotiated with the BS

// --------------------------------------------------------------------------------------------
// UE INITIAL
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan started[UEid_t];    // UE start signal

const int offset_used = -1;    // offset ID used (-1: using default)

// offsets (in ms)
const int offsets[2][UEid_t] =
{
    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
    {10, 20, 5, 0, 10, 40, 7, 15, 30, 0}
};

// VARIABLES ----------------------------------------------------------------------------------

int start_offsets[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // default offset of UE start signal

int BS_assignment[UEid_t] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};    // initial association with the BS

// FUNCTIONS ----------------------------------------------------------------------------------

int getBS(UEid_t id)
{
    return BS_assignment[id];
}

void setOffset()    // setting offset values from possible variations in offsets
{
    if(offset_used != -1)
        for(i: UEid_t) start_offsets[i] = offsets[offset_used][i] * 1000 * unit;
}

// --------------------------------------------------------------------------------------------
// UE CONNECT
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan connected[UEid_t];    // UE connected signal

broadcast chan disconnected[UEid_t];    // UE disconnected signal

broadcast chan failed[UEid_t];    // UE signal for failed latency requirements

broadcast chan RACH[BSid_t];    // UE signal to BS through the random access channel in order to connect

const int disconnect_timeout = 5000 * 1000 * unit;    // timeout for disconnect in us

// VARIABLES ----------------------------------------------------------------------------------

// connection channel stability
int connection_channel_stability[UEid_t][2] =
{
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75}
};

int RACH_slot[BSid_t] = {number_UE, number_UE};

int RACH_start[BSid_t] = {0, 0};    // start time of random access channel in the current frame

int RACH_size[BSid_t] = {0, 0};  // size of random access channel slots (us * unit)

int RACH_id[BSid_t] = {-1, -1};    // UE id which sends RACH signal in the current RACH slot

bool ACK[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // BS acknowledge of the initial UL resource request from the UE

// --------------------------------------------------------------------------------------------
// LISTEN_ONLY
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

const int number_channels = 10;    // number of hard-coded channel frequencies to scan through

const int channels[number_channels] = {1500, 1800, 2000, 2200, 2300, 2400, 3100, 3500, 4200, 5000};    // channel frequencies (kHz) to scan for BS down-link reception

broadcast chan BCH[number_channels];    // broadcast channel

broadcast chan listen[UEid_t];    // UE to set Listen-Only mode signal

broadcast chan UCCH[BSid_t][slotID_t];    // Up-Link control channel

// VARIABLES ----------------------------------------------------------------------------------

// initial channel interference probability
int channel_interference_probability[UEid_t][2] =
{
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75}
};

// --------------------------------------------------------------------------------------------
// TODO
// Channel interference probability is transmission success probability. It must be calculated to
// depend on the UE distance from the BS and used MCS - the error correction level
// --------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------
// STREAM
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan stream[UEid_t];    // UE signal to start audio streaming

broadcast chan sample[UEid_t];    // UE signal to DSP to start audio sampling

broadcast chan stop_sample[UEid_t];    // UE signal to DSP to stop audio sampling (in case of mode changes)

broadcast chan sample_ready[UEid_t];    // UE signal from DSP that a new audio sample is ready loaded in the memory

broadcast chan UTCH[BSid_t][slotID_t];    // up-link UE signal to BS transmitting audio data

// VARIABLES ----------------------------------------------------------------------------------

int samples_ready[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // audio samples ready to be read from memory

int samples_lost[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // audio samples that were lost because of moving relevant sample window

// FUNCTIONS ----------------------------------------------------------------------------------

int24_t getLatency(UEid_t id)
{
    return latency[static_profile[id]] * 1000 * unit;    // us
}

//double dsp_to_qca(){
//    return (frame_size/1000 * audio_data_rate)/uart_speed;
//}

// --------------------------------------------------------------------------------------------
// QUEUE
// --------------------------------------------------------------------------------------------

typedef struct {
    int prior;    // priority identification (depending on QoS and CQI)
    UEid_t id;    // UE's ID
} Node_t;

typedef struct {
    int front;
    int rear;
    int size;
    Node_t queue[UEid_t];
} Queue_t;

bool isEmpty(Queue_t q){
    return q.size &lt;= 0;
}

bool isFull(Queue_t q)
{
    return q.size == number_UE;
}

int getSize(Queue_t q)
{
    return q.size;
}

Node_t getFirst(Queue_t q)
{
    return q.queue[q.front];
}

Node_t getLast(Queue_t q)
{
    return q.queue[q.rear];
}

int insert(Node_t value, Queue_t &amp;q)    // add a node according to its priority
{
    int i = 0;
    bool found = false;

    if(!isFull(q)){
        if(isEmpty(q))
        {
            q.queue[++q.size] = value;
            q.front = q.rear = 0;
        }
        else
        {
            for(i = q.size-1; i &gt;= 0; i--)
            {
                if(value.prior &gt; q.queue[i].prior &amp;&amp; !found)
                {
                    q.queue[i+1] = q.queue[i];
                    found = true;
                }
            }
            q.queue[i] = value;
            q.size++;
        }
        return 0;
    }
    else
    {
        // Queue is full
        return -1;
    }
}

int enqueue(Node_t value, Queue_t &amp;q)    // add a node at the end of the queue
{
    if(q.size &lt; number_UE)
    {
        if(isEmpty(q))
        {
            q.queue[0] = value;
            q.front = q.rear = 0;
            q.size = 1;
        }
        else if(q.rear == number_UE - 1)
        {
            q.queue[0] = value;
            q.rear = 0;
            q.size++;
        }
        else
        {
            q.queue[q.rear + 1] = value;
            q.rear++;
            q.size++;
        }
        return 0;
    }
    else
    {
        // Queue is full
        return -1;
    }
}

int pop(Queue_t q)
{
    if(isEmpty(q))
    {
        // Queue is empty
        return -1;
    }
    else
    {
        Node_t value = getLast(q);
        q.size--;
        q.rear--;
        return value.id;
    }
}

int dequeue(Queue_t q)
{

    if(isEmpty(q))
    {
        // Queue is empty
        return -1;
    }
    else
    {
        Node_t value = getFirst(q);
        q.size--;
        q.front++;
        return value.id;
    }
}

// --------------------------------------------------------------------------------------------
// BASE STATION
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan schedule[BSid_t];    // BS signal to execute radio resource scheduling

broadcast chan frame_start[BSid_t];    // Frame clock reset signal (clock interrupt)

broadcast chan transmit_ready[BSid_t];    // RRM signal to BS that scheduling is done

broadcast chan retransmit_ready[BSid_t];    // RRM signal to BS that retransmission scheduling is done

broadcast chan processing[UEid_t];    // BS QCA signal to DSP to internally process data

const int broadcast_channel[BSid_t] = {2, 7};    // BCH transmission channel frequencies (kHz)

const int retransmission_channel[BSid_t] = {4, 9};    // BCH retransmission channel frequencies (kHz)

const int channel_switch = 244 * unit;    // frequency change latency

// VARIABLES ----------------------------------------------------------------------------------

int bch_interference_probability[BSid_t][2] =
{
    {10, 90},
    {10, 90}
};

bool retransmission[BSid_t] = {false, false};

int number_slots[BSid_t] = {0, 0};    //  UTCHs, UCCHs and RACH

Queue_t priority_queue[BSid_t] =    // Queue of active devices with profiles RTa, hqRTa and sRTA
{
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}},
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}}
};

Queue_t request_queue[BSid_t] =    // Queue of active devices in connected and Listen-Only modes
{
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}},
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}}
};

bool active_UE[BSid_t][UEid_t] = {    // identification of UE that are active
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};

bool listen_only_UE[BSid_t][UEid_t] = {    // identification of UE that are in Listen-Only mode
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};

bool connected_UE[BSid_t][UEid_t] = {    // identification of UE that are in initial connected mode
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};

int UE_CQI[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // channel quality indications of all active UE

int current_slot[BSid_t] = {-1, -1};

// FUNCTIONS ----------------------------------------------------------------------------------
// Get number of active, listeners and connected UE
int getActive(BSid_t bs)
{
    int counter = 0;
    for(i: UEid_t)
    {
        if(active_UE[bs][i])
            counter++;
    }
    return counter;
}

int getListeners(BSid_t bs)
{
    int counter = 0;
    for(i: UEid_t)
    {
        if(listen_only_UE[bs][i])
            counter++;
    }
    return counter;
}

int getConnected(BSid_t bs)
{
    int counter = 0;
    for(i: UEid_t)
    {
        if(listen_only_UE[bs][i])
            counter++;
    }
    return counter;
}

// --------------------------------------------------------------------------------------------

int BCH_meta_bits;
int BCH_slot_audio_bits;

// Frame-based sampling approach for the initial case
// Note: max capacity of BCH headers is 40 Bytes
int getBCHDuration(BSid_t bs)    // in us
{
    int streaming, listening, connected;
    int BCH_slot_meta_bits = 5 * 8;
    //                             in us
    BCH_meta_bits = (((512 * 1024)/frame_size[bs]/8) + 64) * 8;
    //                                           in us
    BCH_slot_audio_bits = (audio_quality/1000) * frame_size[bs] + BCH_slot_meta_bits;
    // BCH size for streaming, Listening-Only and connected UEs
    streaming = (BCH_slot_meta_bits + BCH_slot_audio_bits) * getActive(bs);
    listening = (BCH_slot_meta_bits + BCH_slot_audio_bits) * getListeners(bs);
    connected = BCH_slot_meta_bits * getConnected(bs);
    return (BCH_meta_bits + streaming + listening  + connected)/data_rate[bs];
}

int getULMetaData()
{
    return 20 * 8;
}

int getULMetaDuration(BSid_t bs)    // in us
{
    return getULMetaData()/data_rate[bs];
}

int getULAudioData(BSid_t bs)
{
    return (audio_quality/1000) * frame_size[bs] + getULMetaData();
}

int getULAudioDuration(BSid_t bs)    // in us
{
    return getULAudioData(bs)/data_rate[bs];
}

int getRACHData()
{
    return 176 * 8;
}

int getRACHDuration(BSid_t bs)    // in us
{
    return getRACHData()/data_rate[bs];
}

// --------------------------------------------------------------------------------------------

void add_UE(BSid_t bs, UEid_t id)
{
    Node_t new_node = {-1, id};
    ACK[id] = true;
    if(static_profile[id] == initial)
    {
        connected_UE[bs][id] = true;
    }
    else if(static_profile[id] == Listen_Only)
    {
        listen_only_UE[bs][id] = true;
    }
    else
    {
        active_UE[bs][id] = true;
        //new_node.prior = profile[id];
        //insert(new_node, priority_queue[bs]);
        return;
    }
    //enqueue(new_node, request_queue[bs]);
}

// --------------------------------------------------------------------------------------------
// SLEEP MODE
// --------------------------------------------------------------------------------------------

broadcast chan sleep[UEid_t];    // UE signal for RF module to sleep

broadcast chan wake_up[UEid_t];    // UE signal for RF module to wake-up

int sleep_time[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // RRM (Radio Resource Manager) calculated sleep time for UE after receiving UL ACKs</declaration>
	<template>
		<name>InternalProcessing</name>
		<parameter>UEid_t id, int uart_speed</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int AES_bit_clock = 12288;    // kHz

const int internal_processing = 50;    // us

const int cb_processing = 50;    // audio data processing time in central base (in us)

const int decode_time = 1/(44000 * 1000000);    // audio decoding time with 44kHz packet rate (in us)

const int qca_processing = 50;    // QCA processing time (in us)

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // general utility timer

bool isAudio = false;

int aes_transmit = 0;

int uart_latency;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int getAESTime()
{
    return getULAudioData(id)/(AES_bit_clock/1000);
}

int getDataType()
{
    int i = owner[id][current_slot[id]];
    if(i &gt; number_UE &amp;&amp; profile[i] == RTa)
        return true;
    return false;
}

int getUARTTime()
{
    return getULAudioData(id)/(uart_speed/1000);
}

// --------------------------------------------------------------------------------------------
// TODO
// 44kHz is sampling rate
// Have a separate template for UE and BS internal processing (or handle the IDs so there wouldn't
// be any overlay)
// --------------------------------------------------------------------------------------------</declaration>
		<location id="id0" x="-569" y="-306" color="#ffffff">
			<name x="-629" y="-314">INITIAL</name>
		</location>
		<location id="id1" x="-187" y="-204" color="#ff00ff">
			<name x="-229" y="-187">PROCESS_INTERNAL</name>
			<label kind="invariant" x="-229" y="-170">x &lt;= internal_processing</label>
		</location>
		<location id="id2" x="-365" y="-204">
			<name x="-416" y="-187">TRANSFER_AES</name>
			<label kind="invariant" x="-416" y="-170">x &lt;= aes_transmit</label>
			<label kind="comments" x="-408" y="-144">To Central Base</label>
		</location>
		<location id="id3" x="-187" y="-399" color="#ff00ff">
			<name x="-221" y="-450">DECODE_AUDIO</name>
			<label kind="invariant" x="-221" y="-433">x &lt;= decode_time</label>
		</location>
		<location id="id4" x="-187" y="-306">
			<urgent/>
		</location>
		<location id="id5" x="-569" y="-399" color="#ff00ff">
			<name x="-663" y="-450">PROCESS_CENTRAL_BASE</name>
			<label kind="invariant" x="-620" y="-433">x &lt;= cb_processing</label>
		</location>
		<location id="id6" x="-569" y="-204">
			<name x="-706" y="-221">TRANSFER_UART</name>
			<label kind="invariant" x="-697" y="-204">x &lt;= uart_latency</label>
			<label kind="comments" x="-739" y="-246">QCA to host processor</label>
		</location>
		<init ref="id0"/>
		<transition>
			<source ref="id6"/>
			<target ref="id2"/>
			<label kind="guard" x="-552" y="-204">x &gt;= uart_latency</label>
			<label kind="assignment" x="-552" y="-187">x = 0</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id0"/>
			<label kind="guard" x="-561" y="-382">x &gt;= cb_processing</label>
			<label kind="assignment" x="-561" y="-365">x = 0</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="guard" x="-399" y="-433">x &gt;= decode_time</label>
			<label kind="assignment" x="-399" y="-416">x = 0</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id0"/>
			<label kind="guard" x="-399" y="-331">!isAudio</label>
			<label kind="assignment" x="-399" y="-306">x = 0</label>
			<nail x="-357" y="-306"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="guard" x="-331" y="-238">x &gt;= aes_transmit</label>
			<label kind="assignment" x="-331" y="-221">x = 0</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-178" y="-382">isAudio</label>
			<label kind="assignment" x="-178" y="-365">x = 0,
aes_transmit = getAESTime()</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="guard" x="-178" y="-289">x &gt;= internal_processing</label>
			<label kind="assignment" x="-178" y="-272">x = 0,
isAudio = getDataType()</label>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-561" y="-289">processing[id]?</label>
			<label kind="assignment" x="-561" y="-272">x = 0,
uart_latency = getUARTTime()</label>
		</transition>
	</template>
	<template>
		<name>Scheduler</name>
		<parameter>BSid_t bs</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

bool success = false;    // Successful scheduling indication

int disconnect_UE = -1;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int scheduleRF()
{
    bool new_entrants = false;
    for(i: UEid_t)
    {
        if(ACK[i])
        {
            new_entrants = true;
        }
    }
    if(!success || new_entrants)
    {
        int j = 0;
        int BCH_end;
        int slot_count;    // BCH, UTCHs, UCCHs and RACH
        int start_time = 0;
        int transmission_duration = frame_size[bs]/2;
        int UL_duration = getULAudioDuration(bs) * getActive(bs) + getULMetaDuration(bs) * (getListeners(bs) + getConnected(bs));

        BCH_end = channel_switch + getBCHDuration(bs);
        RACH_size[bs] = getRACHDuration(bs);
        number_slots[bs] = getActive(bs) + getListeners(bs) + 1;
        slot_count = 2 + number_slots[bs];
        GI_size[bs] = (transmission_duration - (BCH_end + UL_duration + RACH_size[bs]))/slot_count;

        // GI verification
        if(GI_size[bs] &lt; GI[bs])    // actual GI size must be &gt;= of GI required by MCS used
        {
            // drop Listen-Only node and re-evaluate
            for(i: UEid_t)
            {
                if(listen_only_UE[bs][i])
                {
                    disconnect_UE = i;
                    return 0;
                }
            }
            // drop streaming node and re-evaluate, if no Listen-Only nodes available
            for(i: UEid_t)
            {
                if(active_UE[bs][i])
                {
                    disconnect_UE = i;
                    return 0;
                }
            }
            disconnect_UE = -1;    // unschedulable - erroneous frame setup
            return 0;
        }

        // slot start calculation
        start_time = BCH_end + GI_size[bs];
        for(i: UEid_t)
        {
            if(active_UE[bs][i])
            {
                owner[bs][j++] = i;
                slot_size[bs][i] = getULAudioDuration(bs);
                slot_data[bs][i] = getULAudioData(bs);
                slot_start[bs][i] = start_time;
                start_time = slot_start[bs][i] + slot_size[bs][i]  + GI_size[bs];
            }
        }
        for(i: UEid_t)
        {
            if(listen_only_UE[bs][i])
            {
                owner[bs][j++] = i;
                slot_size[bs][i] = getULMetaDuration(bs);
                slot_data[bs][i] = getULMetaData();
                slot_start[bs][i] = start_time;
                start_time = slot_start[bs][i] + slot_size[bs][i] + GI_size[bs];
            }
        }
        for(i: UEid_t)
        {
            if(connected_UE[bs][i])
            {
                owner[bs][j++] = i;
                slot_size[bs][i] = getULMetaDuration(bs);
                slot_data[bs][i] = getULMetaData();
                slot_start[bs][i] = start_time;
                start_time = slot_start[bs][i] + slot_size[bs][i] + GI_size[bs];
            }
        }
        owner[bs][j++] = number_UE;
        slot_size[bs][number_UE] = RACH_size[bs];
        slot_data[bs][number_UE] = getRACHData();
        slot_start[bs][number_UE] = start_time;
        RACH_start[bs] = start_time;
    }
    return 1;
}

// --------------------------------------------------------------------------------------------
// TODO
// in the ACK enabled version: reset the ACK
// --------------------------------------------------------------------------------------------
</declaration>
		<location id="id7" x="-841" y="-519" color="#ffffff">
			<name x="-851" y="-553">INITIAL</name>
		</location>
		<location id="id8" x="-841" y="-374">
			<name x="-918" y="-399">STARTED</name>
			<urgent/>
		</location>
		<location id="id9" x="-603" y="-280">
			<name x="-628" y="-263">FINISHED</name>
			<urgent/>
		</location>
		<location id="id10" x="-1028" y="-374">
			<name x="-1088" y="-357">RETRANSMISSION</name>
			<label kind="comments" x="-1130" y="-331">Retransmission uses the same
schedule as initial transmission -
no need for extra scheduling.</label>
			<urgent/>
		</location>
		<location id="id11" x="-603" y="-425">
			<name x="-620" y="-459">RETRY</name>
			<urgent/>
		</location>
		<location id="id12" x="-782" y="-374">
			<name x="-817" y="-408">UNSCHEDULABLE</name>
			<urgent/>
		</location>
		<init ref="id7"/>
		<transition>
			<source ref="id10"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-1020" y="-544">retransmit_ready[bs]!</label>
			<nail x="-1028" y="-518"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id8"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id12"/>
			<label kind="guard" x="-756" y="-374">disconnect_UE == -1</label>
			<nail x="-620" y="-374"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id8"/>
			<label kind="guard" x="-816" y="-468">disconnect_UE != -1</label>
			<label kind="synchronisation" x="-816" y="-451">disconnected[disconnect_UE]!</label>
			<nail x="-817" y="-425"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id11"/>
			<label kind="guard" x="-603" y="-340">!success</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id10"/>
			<label kind="guard" x="-986" y="-374">retransmission[bs]</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id7"/>
			<label kind="guard" x="-654" y="-561">success</label>
			<label kind="synchronisation" x="-654" y="-544">transmit_ready[bs]!</label>
			<nail x="-536" y="-279"/>
			<nail x="-536" y="-518"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id9"/>
			<label kind="guard" x="-790" y="-306">!retransmission[bs]</label>
			<label kind="assignment" x="-790" y="-281">success = scheduleRF()</label>
			<nail x="-841" y="-280"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-935" y="-459">schedule[bs]?</label>
		</transition>
	</template>
	<template>
		<name>FrameClock</name>
		<parameter>BSid_t bs</parameter>
		<location id="id13" x="-561" y="-170" color="#ffffff">
			<name x="-586" y="-204">INITIAL</name>
		</location>
		<location id="id14" x="-561" y="-34">
			<name x="-603" y="-17">FRAME_TIME</name>
			<label kind="invariant" x="-637" y="0">frame_clk[bs] &lt;= frame_size[bs]/2</label>
		</location>
		<location id="id15" x="-561" y="-102">
			<urgent/>
		</location>
		<init ref="id13"/>
		<transition>
			<source ref="id15"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-671" y="-76">frame_start[bs]!</label>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id14"/>
			<label kind="guard" x="-450" y="-102">frame_clk[bs] &gt;= frame_size[bs]/2</label>
			<label kind="synchronisation" x="-450" y="-119">frame_start[bs]!</label>
			<label kind="assignment" x="-450" y="-85">frame_clk[bs] = 0</label>
			<nail x="-459" y="-34"/>
			<nail x="-459" y="-119"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-697" y="-153">transmit_ready[bs]?</label>
		</transition>
	</template>
	<template>
		<name>BaseStation</name>
		<parameter>BSid_t bs</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int qca_processing = 25;    // QCA processing time (in us)

const int uart_speed = 6250;    // uart transmission speed (in kbit/s)

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // general utility timer

int channel;    // BS DL channel

slotID_t ue;    // current slot owner

UEid_t new;    // ID of current slot's owner (UE)

int BCH_duration;

int prob_failure;
int prob_success;

int uart_latency;

int slot = 0;    // slot counter during the frame execution

bool success[slotID_t] = {false, false, false, false, false, false, false, false, false, false, false};

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_success = connection_channel_stability[bs][1];
    prob_failure = connection_channel_stability[bs][0];
}

int getUARTTime()
{
    return getULAudioData(bs)/(uart_speed/1000);
}

int getDataType()
{
    int i = owner[bs][ue];
    if(i &gt; number_UE &amp;&amp; static_profile[i] == RTa)
        return true;
    if(i &gt; number_UE &amp;&amp; static_profile[i] == sRTa)
        return true;
    if(i &gt; number_UE &amp;&amp; static_profile[i] == HqRTa)
        return true;
    if(i &gt; number_UE &amp;&amp; static_profile[i] == Listen_Only)
        return true;
    return false;
}

// --------------------------------------------------------------------------------------------
// TODO
// Have a transition with the reverse probability going to other location for failure handling
// --------------------------------------------------------------------------------------------
</declaration>
		<location id="id16" x="-842" y="-1046" color="#ffffff">
			<name x="-867" y="-1079">INITIAL</name>
			<urgent/>
		</location>
		<location id="id17" x="-170" y="-850">
			<name x="-153" y="-867">READY</name>
		</location>
		<location id="id18" x="-170" y="-765" color="#6c3483">
			<name x="-212" y="-748">TRANSMIT_BCH</name>
			<label kind="invariant" x="-238" y="-730">frame_clk[bs] &lt;= BCH_duration</label>
		</location>
		<location id="id19" x="-841" y="-518" color="#ffa500">
			<name x="-824" y="-535">WAIT_UL</name>
			<label kind="invariant" x="-824" y="-518">x &lt;= slot_size[bs][ue]</label>
		</location>
		<location id="id20" x="-842" y="-850">
			<urgent/>
		</location>
		<location id="id21" x="-1139" y="-357" color="#00ff00">
			<name x="-1164" y="-341">UL_ACK</name>
			<urgent/>
		</location>
		<location id="id22" x="-1139" y="-518" color="#00ffff">
			<name x="-1165" y="-501">UL_NACK</name>
			<urgent/>
		</location>
		<location id="id23" x="-1139" y="-765">
			<name x="-1224" y="-799">NEXT_SLOT</name>
			<urgent/>
		</location>
		<location id="id24" x="-842" y="-961">
			<name x="-960" y="-977">TRANSMISSION</name>
			<urgent/>
		</location>
		<location id="id25" x="-502" y="-850" color="#ffff00">
			<name x="-484" y="-875">RETRANSMISSION</name>
			<urgent/>
		</location>
		<location id="id26" x="-842" y="-764">
			<name x="-824" y="-756">GUARD</name>
			<label kind="invariant" x="-824" y="-739">x' == 1 &amp;&amp;
x &lt;= GI_size[bs]</label>
		</location>
		<location id="id27" x="-680" y="-850">
			<name x="-731" y="-901">SWITCH_CHANNEL</name>
			<label kind="invariant" x="-731" y="-884">x &lt;= channel_switch</label>
		</location>
		<location id="id28" x="-841" y="-637" color="#ffa500">
			<name x="-824" y="-662">WAIT_SLOT</name>
			<label kind="invariant" x="-824" y="-645">frame_clk[bs] &lt;= slot_start[bs][ue]</label>
		</location>
		<location id="id29" x="-1385" y="-357" color="#ff00ff">
			<name x="-1512" y="-366">PROCESS_QCA</name>
			<label kind="invariant" x="-1538" y="-349">x &lt;= qca_processing</label>
			<label kind="comments" x="-1623" y="-365">Meta data</label>
		</location>
		<location id="id30" x="-1385" y="-518" color="#ff00ff">
			<name x="-1547" y="-527">PROCESS_INTERNAL</name>
			<label kind="comments" x="-1572" y="-552">DLC user data and audio</label>
			<urgent/>
		</location>
		<location id="id31" x="-323" y="-960" color="#ffa500">
			<name x="-365" y="-994">WAIT_READY</name>
		</location>
		<location id="id32" x="-501" y="-960" color="#ff00ff">
			<name x="-535" y="-1011">PREPARE</name>
			<label kind="invariant" x="-527" y="-994">x' == 0</label>
			<urgent/>
		</location>
		<location id="id33" x="-1266" y="-518">
			<urgent/>
		</location>
		<branchpoint id="id34" x="-484" y="-765">
		</branchpoint>
		<init ref="id16"/>
		<transition>
			<source ref="id33"/>
			<target ref="id23"/>
			<label kind="assignment" x="-1258" y="-765">slot += 1</label>
			<nail x="-1266" y="-765"/>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id33"/>
			<label kind="guard" x="-1258" y="-467">x &gt;= qca_processing &amp;&amp;
profile[ue] != 0</label>
			<nail x="-1266" y="-399"/>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id32"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-331" y="-850">retransmit_ready[bs]?</label>
			<nail x="-323" y="-850"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-306" y="-960">transmit_ready[bs]?</label>
			<nail x="-170" y="-960"/>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id33"/>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id30"/>
			<label kind="guard" x="-1555" y="-467">x &gt;= qca_processing &amp;&amp;
profile[ue] == 0</label>
			<label kind="synchronisation" x="-1487" y="-425">processing[bs]!</label>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-688" y="-748">BCH[channel]!</label>
			<label kind="assignment" x="-688" y="-731">slot = 0,
x = 0</label>
			<label kind="probability" x="-688" y="-765">1</label>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id19"/>
			<label kind="guard" x="-833" y="-595">frame_clk[bs] &gt;= slot_start[bs][ue]</label>
			<label kind="assignment" x="-833" y="-578">x = 0</label>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id25"/>
			<label kind="guard" x="-663" y="-841">x &gt;= channel_switch</label>
			<label kind="assignment" x="-663" y="-824">x = 0,
channel = retransmission_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id28"/>
			<label kind="guard" x="-952" y="-714">x &gt;= GI_size[bs]</label>
			<label kind="assignment" x="-986" y="-697">current_slot[bs] = slot,
ue = owner[bs][slot]</label>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id32"/>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="-459" y="-960">schedule[bs]!</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id27"/>
			<label kind="guard" x="-816" y="-850">retransmission[bs]</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id24"/>
			<label kind="guard" x="-969" y="-918">!retransmission[bs]</label>
			<label kind="assignment" x="-1054" y="-901">channel = broadcast_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id20"/>
			<label kind="guard" x="-1130" y="-850">slot &gt;= number_slots[bs]</label>
			<label kind="assignment" x="-1130" y="-833">x = 0,
retransmission[bs] = !retransmission[bs]</label>
			<nail x="-1139" y="-850"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id21"/>
			<label kind="guard" x="-833" y="-425">owner[bs][slot] == RACH_slot[bs]</label>
			<label kind="synchronisation" x="-833" y="-408">RACH[bs]?</label>
			<label kind="assignment" x="-833" y="-391">add_UE(bs, RACH_id[bs]),
ue = RACH_id[bs]</label>
			<nail x="-842" y="-357"/>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id23"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id29"/>
			<label kind="assignment" x="-1317" y="-357">x = 0,
RACH_id[bs] = -1</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id26"/>
			<label kind="guard" x="-1113" y="-756">slot &lt; number_slots[bs]</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id22"/>
			<label kind="guard" x="-1071" y="-578">x &gt;= slot_size[bs][ue]</label>
			<label kind="assignment" x="-1071" y="-560">slot += 1,
x = 0</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-1045" y="-425">UTCH[bs][ue]?</label>
			<nail x="-884" y="-399"/>
			<nail x="-1062" y="-399"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-1054" y="-467">UCCH[bs][ue]?</label>
			<nail x="-901" y="-442"/>
			<nail x="-1062" y="-442"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id34"/>
			<label kind="guard" x="-450" y="-765">frame_clk[bs] &gt;= BCH_duration</label>
			<label kind="assignment" x="-450" y="-748">getProbability()</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-161" y="-833">frame_start[bs]?</label>
			<label kind="assignment" x="-161" y="-816">BCH_duration = getBCHDuration(bs)</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id24"/>
			<label kind="assignment" x="-1054" y="-1020">channel = broadcast_channel[bs]</label>
		</transition>
	</template>
	<template>
		<name>UserListenOnly</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int qca_processing = 50;    // QCA processing time (in us)

const int uart_speed = 1000;    // uart transmission speed (in kbit/s)

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // latency timer
clock z;    // disconnect timer

int bs;    // BS that this UE is connected to
int channel;    // BS DL channel

int prob_failure;
int prob_success;

int uart_latency;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_failure = channel_interference_probability[id][0];
    prob_success = channel_interference_probability[id][1];
}
</declaration>
		<location id="id35" x="-1836" y="-1495" color="#ffffff">
			<name x="-1904" y="-1513">INITIAL</name>
			<label kind="invariant" x="-1912" y="-1496">x' == 0 &amp;&amp;
z' == 0</label>
		</location>
		<location id="id36" x="-1198" y="-1496" color="#138d75">
			<name x="-1223" y="-1480">BCH_ACK</name>
			<label kind="invariant" x="-1223" y="-1463">z' == 0</label>
			<urgent/>
		</location>
		<location id="id37" x="-1198" y="-1683" color="#ffa500">
			<name x="-1241" y="-1657">WAIT_SLOT</name>
			<label kind="invariant" x="-1292" y="-1640">frame_clk[bs] &lt;= slot_start[bs][id]</label>
		</location>
		<location id="id38" x="-1513" y="-1385" color="#3498db">
			<name x="-1496" y="-1402">BCH_NACK</name>
			<urgent/>
		</location>
		<location id="id39" x="-1667" y="-1496" color="#ffa500">
			<name x="-1751" y="-1555">WAIT_BCH</name>
			<label kind="invariant" x="-1751" y="-1538">x &lt;= getLatency(id) &amp;&amp;
z &lt;= disconnect_timeout</label>
		</location>
		<location id="id40" x="-1666" y="-1385" color="#4e342e">
			<name x="-1717" y="-1402">FAIL</name>
			<label kind="invariant" x="-1725" y="-1385">z' == 1</label>
			<urgent/>
		</location>
		<location id="id41" x="-1666" y="-1683" color="#4e342e">
			<name x="-1707" y="-1718">DISCONNECT</name>
			<urgent/>
		</location>
		<location id="id42" x="-1453" y="-1683" color="#6c3483">
			<name x="-1487" y="-1734">TRANSMIT</name>
			<label kind="invariant" x="-1512" y="-1717">x &lt;= slot_size[bs][id]/2</label>
		</location>
		<location id="id43" x="-1003" y="-1496" color="#ff00ff">
			<name x="-1045" y="-1478">PROCESS_QCA</name>
			<label kind="invariant" x="-1054" y="-1461">x &lt;= qca_processing</label>
			<label kind="comments" x="-1028" y="-1436">Meta data</label>
		</location>
		<location id="id44" x="-773" y="-1496">
			<name x="-807" y="-1479">TRANSFER</name>
			<label kind="comments" x="-833" y="-1453">QCA to host processor</label>
			<urgent/>
		</location>
		<location id="id45" x="-773" y="-1683" color="#ff00ff">
			<name x="-756" y="-1708">PROCESS_INTERNAL</name>
			<label kind="comments" x="-756" y="-1683">DLC user data and audio</label>
			<urgent/>
		</location>
		<branchpoint id="id46" x="-1453" y="-1614">
		</branchpoint>
		<init ref="id35"/>
		<transition>
			<source ref="id36"/>
			<target ref="id43"/>
		</transition>
		<transition>
			<source ref="id45"/>
			<target ref="id37"/>
			<label kind="guard" x="-1139" y="-1683">retransmission[bs]</label>
			<label kind="assignment" x="-1139" y="-1666">channel = retransmission_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="-1445" y="-1589">UCCH[bs][id]!</label>
			<label kind="assignment" x="-1445" y="-1572">x = 0</label>
			<label kind="probability" x="-1445" y="-1606">1</label>
			<nail x="-1453" y="-1538"/>
		</transition>
		<transition>
			<source ref="id42"/>
			<target ref="id46"/>
			<label kind="guard" x="-1605" y="-1658">x &gt;= slot_size[bs][id]/2</label>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id35"/>
			<label kind="synchronisation" x="-1826" y="-1701">disconnected[id]!</label>
			<label kind="assignment" x="-1827" y="-1683">z = 0,
x = 0</label>
			<nail x="-1834" y="-1682"/>
		</transition>
		<transition>
			<source ref="id35"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="-1802" y="-1496">listen[id]?</label>
			<label kind="assignment" x="-1802" y="-1479">x = 0,
bs = getBS(id),
channel = broadcast_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id45"/>
			<target ref="id37"/>
			<label kind="guard" x="-986" y="-1827">!retransmission[bs]</label>
			<label kind="assignment" x="-986" y="-1810">channel = broadcast_channel[bs]</label>
			<nail x="-773" y="-1785"/>
			<nail x="-1198" y="-1785"/>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id42"/>
			<label kind="guard" x="-1428" y="-1683">frame_clk[bs] &gt;= slot_start[bs][id]</label>
			<label kind="assignment" x="-1428" y="-1666">x = 0,
getProbability()</label>
		</transition>
		<transition>
			<source ref="id40"/>
			<target ref="id39"/>
		</transition>
		<transition>
			<source ref="id39"/>
			<target ref="id36"/>
			<label kind="guard" x="-1513" y="-1496">x &lt;= getLatency(id)</label>
			<label kind="synchronisation" x="-1513" y="-1513">BCH[channel]?</label>
			<label kind="assignment" x="-1513" y="-1479">z = 0</label>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id40"/>
			<label kind="synchronisation" x="-1623" y="-1402">failed[id]!</label>
			<label kind="assignment" x="-1623" y="-1385">z = x</label>
		</transition>
		<transition>
			<source ref="id39"/>
			<target ref="id38"/>
			<label kind="guard" x="-1504" y="-1428">x &gt;= getLatency(id)</label>
			<nail x="-1513" y="-1436"/>
		</transition>
		<transition>
			<source ref="id39"/>
			<target ref="id41"/>
			<label kind="guard" x="-1768" y="-1615">z &gt;= disconnect_timeout</label>
		</transition>
		<transition>
			<source ref="id43"/>
			<target ref="id44"/>
			<label kind="assignment" x="-901" y="-1521">x = 0</label>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id45"/>
			<label kind="synchronisation" x="-765" y="-1581">processing[id]!</label>
		</transition>
	</template>
	<template>
		<name>UserJoined</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int qca_latency = 50;    // QCA processing time (in us)

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // general utility timer

int prob_success;
int prob_failure;

int bs;    // BS that this UE is connected to
int channel;    // BS DL channel

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_failure = channel_interference_probability[id][0];
    prob_success = channel_interference_probability[id][1];
}

// --------------------------------------------------------------------------------------------
// TODO
// --------------------------------------------------------------------------------------------
</declaration>
		<location id="id47" x="246" y="509">
			<name x="170" y="501">STREAM</name>
		</location>
		<location id="id48" x="246" y="306">
			<urgent/>
		</location>
		<location id="id49" x="8" y="306" color="#ffffff">
			<name x="-10" y="255">INITIAL</name>
			<label kind="invariant" x="-10" y="272">x' == 0</label>
		</location>
		<location id="id50" x="909" y="238" color="#138d75">
			<name x="884" y="255">BCH_ACK</name>
			<urgent/>
		</location>
		<location id="id51" x="909" y="93" color="#ffa500">
			<name x="867" y="42">WAIT_SLOT</name>
			<label kind="invariant" x="833" y="59">x &lt;= slot_start[bs][id]</label>
		</location>
		<location id="id52" x="484" y="238" color="#ffa500">
			<name x="493" y="246">WAIT_BCH</name>
			<label kind="invariant" x="493" y="263">x &lt;= disconnect_timeout</label>
		</location>
		<location id="id53" x="484" y="475" color="#4e342e">
			<name x="501" y="450">DISCONNECT</name>
			<urgent/>
		</location>
		<location id="id54" x="688" y="93" color="#6c3483">
			<name x="654" y="42">TRANSMIT</name>
			<label kind="invariant" x="629" y="59">x &lt;= slot_size[bs][id]/2</label>
		</location>
		<location id="id55" x="306" y="391">
			<name x="255" y="399">LISTEN</name>
		</location>
		<location id="id56" x="246" y="238">
			<name x="221" y="204">JOINED</name>
			<urgent/>
		</location>
		<location id="id57" x="909" y="178" color="#ff00ff">
			<name x="824" y="169">PREPARE</name>
			<label kind="invariant" x="782" y="187">x &lt;= qca_latency</label>
		</location>
		<location id="id58" x="484" y="357" color="#0000ff">
			<name x="501" y="348">BCH_NACK</name>
			<urgent/>
		</location>
		<branchpoint id="id59" x="484" y="93">
		</branchpoint>
		<init ref="id49"/>
		<transition>
			<source ref="id58"/>
			<target ref="id53"/>
			<label kind="synchronisation" x="493" y="408">disconnected[id]!</label>
		</transition>
		<transition>
			<source ref="id50"/>
			<target ref="id57"/>
			<label kind="guard" x="960" y="238">retransmission[bs]</label>
			<label kind="assignment" x="960" y="255">channel = retransmission_channel[bs]</label>
			<nail x="1071" y="238"/>
			<nail x="1071" y="178"/>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id51"/>
			<label kind="guard" x="918" y="119">x &gt;= qca_latency</label>
			<label kind="synchronisation" x="918" y="136">processing[id]!</label>
		</transition>
		<transition>
			<source ref="id56"/>
			<target ref="id52"/>
			<label kind="assignment" x="340" y="221">x = 0</label>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id56"/>
			<label kind="guard" x="127" y="263">profile[id] == initial</label>
		</transition>
		<transition>
			<source ref="id55"/>
			<target ref="id53"/>
			<label kind="synchronisation" x="323" y="458">disconnected[id]?</label>
			<nail x="306" y="475"/>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id55"/>
			<label kind="guard" x="280" y="280">static_profile[id] == Listen_Only</label>
			<label kind="synchronisation" x="314" y="314">listen[id]!</label>
			<label kind="assignment" x="314" y="297">profile[id] = Listen_Only</label>
			<nail x="306" y="306"/>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id53"/>
			<label kind="synchronisation" x="263" y="492">disconnected[id]?</label>
			<nail x="484" y="509"/>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id47"/>
			<label kind="guard" x="68" y="391">static_profile[id] == RTa ||
static_profile[id] == HqRTa</label>
			<label kind="synchronisation" x="170" y="450">stream[id]!</label>
			<label kind="assignment" x="136" y="433">profile[id] = RTa</label>
		</transition>
		<transition>
			<source ref="id59"/>
			<target ref="id52"/>
			<label kind="synchronisation" x="493" y="178">UCCH[bs][id]!</label>
			<label kind="assignment" x="493" y="195">x = 0</label>
			<label kind="probability" x="493" y="161">1</label>
		</transition>
		<transition>
			<source ref="id54"/>
			<target ref="id59"/>
			<label kind="guard" x="510" y="93">x &gt;= slot_size[bs][id]/2</label>
		</transition>
		<transition>
			<source ref="id53"/>
			<target ref="id49"/>
			<label kind="assignment" x="17" y="501">x = 0</label>
			<nail x="510" y="475"/>
			<nail x="510" y="526"/>
			<nail x="7" y="526"/>
		</transition>
		<transition>
			<source ref="id49"/>
			<target ref="id48"/>
			<label kind="synchronisation" x="34" y="306">connected[id]?</label>
			<label kind="assignment" x="34" y="323">x = 0,
bs = getBS(id),
channel = broadcast_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id51"/>
			<target ref="id54"/>
			<label kind="guard" x="731" y="93">x &gt;= slot_start[bs][id]</label>
			<label kind="assignment" x="731" y="110">x = 0</label>
		</transition>
		<transition>
			<source ref="id52"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="637" y="212">BCH[channel]?</label>
			<label kind="assignment" x="637" y="238">x = 0</label>
		</transition>
		<transition>
			<source ref="id52"/>
			<target ref="id58"/>
			<label kind="guard" x="493" y="306">x &gt;= disconnect_timeout</label>
		</transition>
		<transition>
			<source ref="id50"/>
			<target ref="id57"/>
			<label kind="guard" x="918" y="195">!retransmission[bs]</label>
			<label kind="assignment" x="918" y="212">channel = broadcast_channel[bs]</label>
		</transition>
	</template>
	<template>
		<name>UserStates</name>
		<parameter>int id, int start_offset</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock offset;    // start offset timer

int mode = 0;    // 1 - Listen Only, 2 - Streaming

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int getOffset()
{
    if(start_offset == -1) {
        setOffset();
        return start_offsets[id];
    }
    else
    {
        return start_offset;
    }
    return 0;
}</declaration>
		<location id="id60" x="-15130" y="-15266" color="#ffffff">
			<name x="-15147" y="-15317">INIT</name>
			<label kind="invariant" x="-15147" y="-15300">offset' == 1</label>
			<urgent/>
		</location>
		<location id="id61" x="-15130" y="-14882">
			<name x="-15240" y="-14883">LISTEN_ONLY</name>
		</location>
		<location id="id62" x="-14832" y="-14882">
			<name x="-14815" y="-14891">STREAMING</name>
		</location>
		<location id="id63" x="-14985" y="-14968" color="#4e342e">
			<name x="-15011" y="-15002">FAILED</name>
			<urgent/>
		</location>
		<location id="id64" x="-14832" y="-15266" color="#4e342e">
			<name x="-14815" y="-15275">DISCONNECTED</name>
			<urgent/>
		</location>
		<location id="id65" x="-15130" y="-15096">
			<name x="-15249" y="-15113">CONNECTING</name>
			<label kind="invariant" x="-15223" y="-15096">offset' == 0</label>
		</location>
		<location id="id66" x="-15130" y="-15181">
			<name x="-15172" y="-15190">ON</name>
			<label kind="invariant" x="-15113" y="-15190">offset &lt;= start_offset</label>
		</location>
		<location id="id67" x="-15130" y="-15019">
			<name x="-15198" y="-15036">JOINED</name>
		</location>
		<init ref="id60"/>
		<transition>
			<source ref="id67"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-14934" y="-15045">stream[id]?</label>
			<label kind="assignment" x="-14934" y="-15019">mode = 2</label>
			<nail x="-14866" y="-15019"/>
		</transition>
		<transition>
			<source ref="id67"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-14977" y="-15079">disconnected[id]?</label>
			<nail x="-15104" y="-15053"/>
			<nail x="-14866" y="-15053"/>
		</transition>
		<transition>
			<source ref="id67"/>
			<target ref="id61"/>
			<label kind="synchronisation" x="-15198" y="-14968">listen[id]?</label>
			<label kind="assignment" x="-15198" y="-14951">mode = 1</label>
		</transition>
		<transition>
			<source ref="id66"/>
			<target ref="id65"/>
			<label kind="guard" x="-15121" y="-15155">offset &gt;= start_offset</label>
			<label kind="synchronisation" x="-15121" y="-15138">started[id]!</label>
		</transition>
		<transition>
			<source ref="id65"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-14985" y="-15121">disconnected[id]?</label>
			<nail x="-14875" y="-15096"/>
		</transition>
		<transition>
			<source ref="id65"/>
			<target ref="id67"/>
			<label kind="synchronisation" x="-15232" y="-15070">connected[id]?</label>
		</transition>
		<transition>
			<source ref="id63"/>
			<target ref="id61"/>
			<label kind="guard" x="-15096" y="-14934">mode == 1</label>
			<nail x="-15028" y="-14917"/>
			<nail x="-15104" y="-14917"/>
		</transition>
		<transition>
			<source ref="id61"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-15266" y="-15342">disconnected[id]?</label>
			<nail x="-15266" y="-14883"/>
			<nail x="-15266" y="-15316"/>
			<nail x="-14832" y="-15316"/>
		</transition>
		<transition>
			<source ref="id64"/>
			<target ref="id60"/>
		</transition>
		<transition>
			<source ref="id62"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-14824" y="-15079">disconnected[id]?</label>
		</transition>
		<transition>
			<source ref="id63"/>
			<target ref="id62"/>
			<label kind="guard" x="-14943" y="-14934">mode == 2</label>
			<nail x="-14951" y="-14917"/>
			<nail x="-14866" y="-14917"/>
		</transition>
		<transition>
			<source ref="id61"/>
			<target ref="id63"/>
			<label kind="synchronisation" x="-15087" y="-14985">failed[id]?</label>
			<nail x="-15104" y="-14968"/>
		</transition>
		<transition>
			<source ref="id62"/>
			<target ref="id63"/>
			<label kind="synchronisation" x="-14926" y="-14985">failed[id]?</label>
			<nail x="-14858" y="-14968"/>
		</transition>
		<transition>
			<source ref="id62"/>
			<target ref="id61"/>
			<label kind="synchronisation" x="-15036" y="-14849">stop_sample[id]?</label>
			<nail x="-14832" y="-14832"/>
			<nail x="-15130" y="-14832"/>
		</transition>
		<transition>
			<source ref="id61"/>
			<target ref="id62"/>
			<label kind="synchronisation" x="-15028" y="-14900">stream[id]?</label>
			<label kind="assignment" x="-15028" y="-14883">mode = 2</label>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id66"/>
			<label kind="assignment" x="-15121" y="-15257">offset = 0,
start_offset = getOffset(),
mode = 0</label>
		</transition>
	</template>
	<template>
		<name>UserStream</name>
		<parameter>UEid_t id, int dma_latency</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int qca_latency = 50;    // QCA processing time (in us)

const int uart_speed = 1000;    // uart transmission speed (in kbit/s)

const int codec_latency = 1/(44000 * 1000000);    // 44kHz packet rate

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // DMA delay timer
clock y;    // general usage timer
clock z;    // disconnect timer

BSid_t bs;    // BS that this UE is connected to
int channel;    // BS DL channel

int uart_latency = 0;

bool transmitted;

int prob_success;
int prob_failure;

// packet preparation time: QCA + DMA latencies
// can use samples prepared from last successful transmission to (slot start time - preparation time)

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_success = channel_interference_probability[id][0];
    prob_failure = channel_interference_probability[id][1];
}

void isTransmitted()
{
    if(retransmission[bs] &amp;&amp; !transmitted)
    {
        samples_lost[id] += samples_ready[id];
    }
}

int getUARTTime()
{
    return getULAudioData(id)/(uart_speed/1000);
}

// --------------------------------------------------------------------------------------------
// TODO
// --------------------------------------------------------------------------------------------</declaration>
		<location id="id68" x="-1139" y="-1020" color="#ffffff">
			<name x="-1164" y="-1105">INITIAL</name>
			<label kind="invariant" x="-1164" y="-1088">x' == 0 &amp;&amp;
y' == 0 &amp;&amp;
z' == 0</label>
		</location>
		<location id="id69" x="-1300" y="-799" color="#4e342e">
			<name x="-1368" y="-808">FAILED</name>
			<urgent/>
		</location>
		<location id="id70" x="-1299" y="-1020" color="#4e342e">
			<name x="-1342" y="-1054">DISCONNECT</name>
			<urgent/>
		</location>
		<location id="id71" x="-807" y="-994" color="#ff00ff">
			<name x="-884" y="-1028">PREPARE</name>
			<urgent/>
		</location>
		<location id="id72" x="-595" y="-952" color="#ffa500">
			<name x="-646" y="-986">WAIT_SAMPLES</name>
		</location>
		<location id="id73" x="-773" y="-654" color="#6c3483">
			<name x="-833" y="-722">TRANSMIT</name>
			<label kind="invariant" x="-833" y="-705">x' == 1 &amp;&amp;
x &lt;= slot_size[bs][id]/2</label>
		</location>
		<location id="id74" x="-807" y="-799" color="#138d75">
			<name x="-884" y="-841">BCH_ACK</name>
			<label kind="invariant" x="-858" y="-824">y' == 0</label>
			<urgent/>
		</location>
		<location id="id75" x="-399" y="-799">
			<name x="-382" y="-816">PROCESS_QCA</name>
			<label kind="invariant" x="-382" y="-799">x &lt;= qca_latency</label>
		</location>
		<location id="id76" x="-1300" y="-935" color="#3498db">
			<name x="-1393" y="-952">BCH_NACK</name>
			<label kind="invariant" x="-1393" y="-935">y' == 1</label>
			<urgent/>
		</location>
		<location id="id77" x="-510" y="-799" color="#ffff00">
			<name x="-552" y="-833">RETRANSMIT</name>
			<urgent/>
		</location>
		<location id="id78" x="-399" y="-654" color="#ffa500">
			<name x="-382" y="-671">WAIT_SLOT</name>
			<label kind="invariant" x="-382" y="-654">x' == 0 &amp;&amp;
frame_clk[bs] &lt;= slot_start[bs][id]</label>
		</location>
		<location id="id79" x="-986" y="-1020">
			<urgent/>
		</location>
		<location id="id80" x="-986" y="-799" color="#ffa500">
			<name x="-1122" y="-858">WAIT_BCH</name>
			<label kind="invariant" x="-1122" y="-841">x' == 1 &amp;&amp;
x &lt;= getLatency(id)</label>
		</location>
		<location id="id81" x="-1147" y="-654">
			<urgent/>
		</location>
		<location id="id82" x="-807" y="-892">
			<name x="-892" y="-918">PROCESS</name>
			<label kind="invariant" x="-935" y="-901">x &lt;= qca_latency</label>
		</location>
		<location id="id83" x="-442" y="-739">
			<urgent/>
		</location>
		<branchpoint id="id84" x="-986" y="-654">
		</branchpoint>
		<init ref="id68"/>
		<transition>
			<source ref="id83"/>
			<target ref="id75"/>
			<label kind="guard" x="-518" y="-892">frame_clk[bs] + qca_latency &lt; slot_start[bs][id]</label>
		</transition>
		<transition>
			<source ref="id83"/>
			<target ref="id80"/>
			<label kind="guard" x="-739" y="-739">frame_clk[bs] + qca_latency &gt;= slot_start[bs][id]</label>
			<nail x="-935" y="-739"/>
		</transition>
		<transition>
			<source ref="id82"/>
			<target ref="id71"/>
			<label kind="guard" x="-918" y="-952">x &gt;= qca_latency</label>
			<label kind="synchronisation" x="-909" y="-969">processing[id]!</label>
		</transition>
		<transition>
			<source ref="id81"/>
			<target ref="id80"/>
			<label kind="guard" x="-1275" y="-705">!retransmission[bs]</label>
			<nail x="-1147" y="-714"/>
		</transition>
		<transition>
			<source ref="id81"/>
			<target ref="id69"/>
			<label kind="guard" x="-1300" y="-654">retransmission[bs] &amp;&amp;
!transmitted</label>
			<nail x="-1300" y="-654"/>
		</transition>
		<transition>
			<source ref="id72"/>
			<target ref="id83"/>
			<label kind="synchronisation" x="-569" y="-952">sample_ready[id]?</label>
			<label kind="assignment" x="-569" y="-935">x = 0</label>
			<nail x="-442" y="-952"/>
		</transition>
		<transition>
			<source ref="id71"/>
			<target ref="id75"/>
			<label kind="guard" x="-544" y="-1037">samples_ready[id] != 0</label>
			<label kind="assignment" x="-433" y="-1020">x = 0</label>
			<nail x="-399" y="-994"/>
		</transition>
		<transition>
			<source ref="id74"/>
			<target ref="id82"/>
			<label kind="guard" x="-799" y="-875">!retransmission[bs]</label>
			<label kind="assignment" x="-799" y="-858">x = 0,
channel = broadcast_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id80"/>
			<target ref="id74"/>
			<label kind="synchronisation" x="-969" y="-824">BCH[channel]?</label>
			<label kind="assignment" x="-969" y="-799">transmitted = 0</label>
		</transition>
		<transition>
			<source ref="id78"/>
			<target ref="id73"/>
			<label kind="guard" x="-748" y="-654">frame_clk[bs] &gt;= slot_start[bs][id]</label>
			<label kind="assignment" x="-748" y="-637">x = 0</label>
		</transition>
		<transition>
			<source ref="id79"/>
			<target ref="id80"/>
			<label kind="synchronisation" x="-977" y="-994">sample[id]!</label>
		</transition>
		<transition>
			<source ref="id84"/>
			<target ref="id80"/>
			<label kind="synchronisation" x="-977" y="-713">UTCH[bs][id]!</label>
			<label kind="assignment" x="-977" y="-697">transmitted = 1</label>
			<label kind="probability" x="-977" y="-730">1</label>
		</transition>
		<transition>
			<source ref="id77"/>
			<target ref="id75"/>
			<label kind="assignment" x="-493" y="-799">x = 0</label>
			<nail x="-433" y="-799"/>
		</transition>
		<transition>
			<source ref="id76"/>
			<target ref="id69"/>
			<label kind="guard" x="-1462" y="-875">z &lt;= disconnect_timeout</label>
		</transition>
		<transition>
			<source ref="id74"/>
			<target ref="id77"/>
			<label kind="guard" x="-790" y="-799">retransmission[bs]</label>
			<label kind="assignment" x="-790" y="-782">channel = retransmission_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id73"/>
			<target ref="id84"/>
			<label kind="guard" x="-960" y="-654">x &gt;= slot_size[bs][id]/2</label>
			<label kind="assignment" x="-960" y="-637">x = 0,
getProbability()</label>
		</transition>
		<transition>
			<source ref="id75"/>
			<target ref="id78"/>
			<label kind="guard" x="-391" y="-739">x &gt;= qca_latency</label>
			<label kind="assignment" x="-391" y="-722">x = 0</label>
		</transition>
		<transition>
			<source ref="id71"/>
			<target ref="id72"/>
			<label kind="guard" x="-773" y="-952">samples_ready[id] == 0</label>
			<nail x="-782" y="-952"/>
		</transition>
		<transition>
			<source ref="id70"/>
			<target ref="id68"/>
			<label kind="synchronisation" x="-1275" y="-1020">disconnected[id]!</label>
		</transition>
		<transition>
			<source ref="id76"/>
			<target ref="id70"/>
			<label kind="guard" x="-1461" y="-986">y &gt;= disconnect_timeout</label>
			<label kind="assignment" x="-1342" y="-1003">y = 0</label>
		</transition>
		<transition>
			<source ref="id69"/>
			<target ref="id80"/>
			<label kind="synchronisation" x="-1266" y="-824">failed[id]!</label>
			<label kind="assignment" x="-1266" y="-799">y = 0,
samples_lost[id] = samples_ready[id]</label>
		</transition>
		<transition>
			<source ref="id80"/>
			<target ref="id76"/>
			<label kind="guard" x="-1215" y="-960">x &gt;= getLatency(id)</label>
			<label kind="assignment" x="-1215" y="-935">y = x</label>
			<nail x="-1020" y="-935"/>
		</transition>
		<transition>
			<source ref="id68"/>
			<target ref="id79"/>
			<label kind="synchronisation" x="-1088" y="-1020">stream[id]?</label>
			<label kind="assignment" x="-1088" y="-1071">bs = getBS(id),
channel = retransmission_channel[bs]</label>
		</transition>
	</template>
	<template>
		<name>UserConnect</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int scan_timeout = 5000;    // time to scan a channel (in us)

const int channel_stability_latency = 100 * unit;    // time to test channel stability before connecting to the BS (in us)

const int number_retries = 10;    // number of allowed retries of channel scanning before going to the INITIAL state

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // general usage timer

int i = 0;    // channel scan counter
int j = 0;    // re-try scan counter

BSid_t bs;    // BS that this UE is connected to
int channel;    // BS DL channel

int prob_stable;
int prob_unstable;

int prob_success;
int prob_failure;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_unstable = connection_channel_stability[id][0];
    prob_stable = connection_channel_stability[id][1];

    prob_success = channel_interference_probability[id][0];
    prob_failure = channel_interference_probability[id][1];
}

bool checkChannel(int ch_id)
{
    for(k: BSid_t)
    {
        if(broadcast_channel[k] == ch_id)
        {
            BS_assignment[id] = k;
            bs = k;
            channel = ch_id;
            return true;
        }
        if(retransmission_channel[k] == ch_id)
        {
            BS_assignment[id] = k;
            bs = k;
            channel = ch_id;
            return true;
        }
    }
    return false;
}

// --------------------------------------------------------------------------------------------
// TODO
// Channel stability should be dependent on the system topology - distance from the UE to the BS
// --------------------------------------------------------------------------------------------

</declaration>
		<location id="id85" x="-3238" y="-3128" color="#ffffff">
			<name x="-3255" y="-3162">INITIAL</name>
		</location>
		<location id="id86" x="-3238" y="-2805">
			<name x="-3221" y="-2822">TEST_CHANNEL</name>
			<label kind="invariant" x="-3221" y="-2805">x &lt;= channel_stability_latency</label>
		</location>
		<location id="id87" x="-3238" y="-3000">
			<urgent/>
		</location>
		<location id="id88" x="-2721" y="-3127">
			<name x="-2755" y="-3160">CONNECTED</name>
			<urgent/>
		</location>
		<location id="id89" x="-2957" y="-2678" color="#ffa500">
			<name x="-3000" y="-2729">WAIT_BCH</name>
			<label kind="invariant" x="-3034" y="-2712">x &lt;= disconnect_timeout</label>
		</location>
		<location id="id90" x="-2958" y="-2473" color="#6c3483">
			<name x="-3060" y="-2465">TRANSMIT</name>
			<label kind="invariant" x="-3085" y="-2448">x &lt;= RACH_size[bs]/2</label>
		</location>
		<location id="id91" x="-2720" y="-2677" color="#138d75">
			<name x="-2704" y="-2693">BCH_ACK</name>
			<urgent/>
		</location>
		<location id="id92" x="-2721" y="-2472" color="#00ffff">
			<name x="-2705" y="-2489">UL_NACK</name>
			<label kind="invariant" x="-2705" y="-2472">frame_clk[bs] &lt;= RACH_start[bs]</label>
		</location>
		<location id="id93" x="-3238" y="-2941">
			<name x="-3289" y="-2932">SCAN</name>
			<label kind="invariant" x="-3357" y="-2915">x &lt;= scan_timeout</label>
		</location>
		<location id="id94" x="-2721" y="-2906" color="#00ff00">
			<name x="-2704" y="-2914">UL_ACK</name>
			<urgent/>
		</location>
		<location id="id95" x="-2958" y="-3094" color="#4e342e">
			<name x="-2941" y="-3102">DISCONNECT</name>
			<urgent/>
		</location>
		<branchpoint id="id96" x="-2958" y="-2575">
		</branchpoint>
		<branchpoint id="id97" x="-3238" y="-2678">
		</branchpoint>
		<init ref="id85"/>
		<transition>
			<source ref="id97"/>
			<target ref="id93"/>
			<label kind="probability" x="-3357" y="-2703">0</label>
			<nail x="-3459" y="-2677"/>
			<nail x="-3459" y="-2856"/>
		</transition>
		<transition>
			<source ref="id96"/>
			<target ref="id89"/>
			<label kind="assignment" x="-2949" y="-2626">RACH_id[bs] = id</label>
			<label kind="probability" x="-2949" y="-2643">prob_success</label>
		</transition>
		<transition>
			<source ref="id95"/>
			<target ref="id85"/>
			<label kind="synchronisation" x="-3136" y="-3111">disconnected[id]!</label>
			<nail x="-3204" y="-3094"/>
		</transition>
		<transition>
			<source ref="id94"/>
			<target ref="id88"/>
		</transition>
		<transition>
			<source ref="id87"/>
			<target ref="id93"/>
			<label kind="assignment" x="-3230" y="-2983">x = 0</label>
		</transition>
		<transition>
			<source ref="id90"/>
			<target ref="id89"/>
			<label kind="guard" x="-3153" y="-2524">x &gt;= RACH_size[bs] ||
RACH_id[bs] != -1</label>
			<label kind="assignment" x="-3153" y="-2490">x = 0</label>
			<nail x="-3018" y="-2473"/>
			<nail x="-3017" y="-2635"/>
		</transition>
		<transition>
			<source ref="id92"/>
			<target ref="id90"/>
			<label kind="guard" x="-2941" y="-2473">frame_clk[bs] &gt;= RACH_start[bs]</label>
			<label kind="assignment" x="-2856" y="-2456">x = 0</label>
		</transition>
		<transition>
			<source ref="id89"/>
			<target ref="id91"/>
			<label kind="guard" x="-2932" y="-2678">x &lt;= disconnect_timeout</label>
			<label kind="synchronisation" x="-2881" y="-2703">BCH[channel]?</label>
			<nail x="-2949" y="-2678"/>
		</transition>
		<transition>
			<source ref="id89"/>
			<target ref="id95"/>
			<label kind="guard" x="-2949" y="-2898">x &gt;= disconnect_timeout</label>
		</transition>
		<transition>
			<source ref="id91"/>
			<target ref="id94"/>
			<label kind="guard" x="-2712" y="-2804">ACK[id] == 1</label>
		</transition>
		<transition>
			<source ref="id90"/>
			<target ref="id96"/>
			<label kind="guard" x="-2949" y="-2575">x &gt;= RACH_size[bs]/2 &amp;&amp;
RACH_id[bs] == -1</label>
			<label kind="synchronisation" x="-2949" y="-2541">RACH[bs]!</label>
			<label kind="assignment" x="-2950" y="-2524">x = 0</label>
			<nail x="-2958" y="-2558"/>
		</transition>
		<transition>
			<source ref="id91"/>
			<target ref="id92"/>
			<label kind="guard" x="-2712" y="-2566">ACK[id] == 0</label>
		</transition>
		<transition>
			<source ref="id88"/>
			<target ref="id85"/>
			<label kind="synchronisation" x="-3026" y="-3170">connected[id]!</label>
			<label kind="assignment" x="-3026" y="-3153">profile[id] = static_profile[id]</label>
		</transition>
		<transition>
			<source ref="id93"/>
			<target ref="id87"/>
			<label kind="guard" x="-3451" y="-3000">x &gt;= scan_timeout &amp;&amp;
i &gt;= number_channels &amp;&amp;
j &lt; number_retries</label>
			<label kind="assignment" x="-3451" y="-2941">i = 0,
j++</label>
			<nail x="-3459" y="-2941"/>
			<nail x="-3459" y="-3000"/>
		</transition>
		<transition>
			<source ref="id87"/>
			<target ref="id85"/>
			<label kind="guard" x="-3425" y="-3128">j &gt;= number_retries</label>
			<label kind="synchronisation" x="-3408" y="-3111">disconnected[id]!</label>
			<label kind="assignment" x="-3340" y="-3094">i = 0,
j = 0</label>
			<nail x="-3298" y="-3026"/>
			<nail x="-3298" y="-3128"/>
		</transition>
		<transition>
			<source ref="id93"/>
			<target ref="id87"/>
			<label kind="guard" x="-3051" y="-2992">x &gt;= scan_timeout &amp;&amp;
i &lt; number_channels</label>
			<label kind="assignment" x="-3051" y="-2958">i++</label>
			<nail x="-3060" y="-2941"/>
			<nail x="-3059" y="-3000"/>
		</transition>
		<transition>
			<source ref="id93"/>
			<target ref="id86"/>
			<label kind="guard" x="-3230" y="-2915">i &lt; number_channels</label>
			<label kind="synchronisation" x="-3230" y="-2898">BCH[i]?</label>
			<label kind="assignment" x="-3230" y="-2881">x = 0,
checkChannel(i)</label>
		</transition>
		<transition>
			<source ref="id97"/>
			<target ref="id89"/>
			<label kind="assignment" x="-3128" y="-2677">i = 0,
j = 0,
x = 0</label>
			<label kind="probability" x="-3128" y="-2703">1</label>
		</transition>
		<transition>
			<source ref="id86"/>
			<target ref="id97"/>
			<label kind="guard" x="-3230" y="-2762">x &gt;= channel_stability_latency</label>
			<label kind="assignment" x="-3230" y="-2745">getProbability()</label>
		</transition>
		<transition>
			<source ref="id85"/>
			<target ref="id87"/>
			<label kind="synchronisation" x="-3230" y="-3085">started[id]?</label>
			<label kind="assignment" x="-3230" y="-3068">i = 0,
j = 0,
profile[id] = initial</label>
		</transition>
	</template>
	<template>
		<name>UserSample</name>
		<parameter>int id, double audio_quality, double bit_depth</parameter>
		<declaration>// id: UE identification number
// audio_quality: audio sampling rate (kHz or kb/s)
// bit_depth: bits per sample

// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // sampling timer
clock y;    // single sample timer

BSid_t bs;

int codec_latency = 10;    // codec processing delay, depends on MCS

int uart_latency = 1;    // UART connection speed between DSP and QCA (Mbits/s)

int samples;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int getSampleTime()
{
    // if audio quality is in bit rate (kbps)
    double sample_rate = audio_quality/bit_depth;    // kHz = 1000 * samples/s
    // if audio quality is in sample rate (kHz)
    double time_per_sample = 1/(sample_rate * 1000 * 1000 * unit);    // us * unit
    int result = fint(time_per_sample);
    return result;
}

int getNumberSamples()
{
    int time = getSampleTime();
    return fint(frame_size[bs]/time);
}</declaration>
		<location id="id98" x="-696" y="-654">
			<name x="-799" y="-697">SAMPLE</name>
			<label kind="invariant" x="-799" y="-680">x &lt;= frame_size[bs]</label>
		</location>
		<location id="id99" x="-416" y="-654">
			<name x="-459" y="-637">PROCESS_CODEC</name>
			<label kind="invariant" x="-459" y="-620">x' == 1 &amp;&amp;
x &lt;= codec_latency</label>
		</location>
		<location id="id100" x="-952" y="-654" color="#ffffff">
			<name x="-978" y="-688">INITIAL</name>
		</location>
		<location id="id101" x="-416" y="-756">
			<name x="-458" y="-807">TRANSFER</name>
			<label kind="invariant" x="-467" y="-790">x &lt;= uart_latency</label>
			<label kind="comments" x="-459" y="-833">DSP to QCA TX</label>
		</location>
		<location id="id102" x="-952" y="-586" color="#4e342e">
			<name x="-1012" y="-595">STOP</name>
			<label kind="testcodeEnter">Add brown color</label>
			<urgent/>
		</location>
		<init ref="id100"/>
		<transition>
			<source ref="id98"/>
			<target ref="id99"/>
			<label kind="guard" x="-603" y="-680">x &gt;= frame_size[bs]</label>
			<label kind="assignment" x="-603" y="-654">x = 0</label>
		</transition>
		<transition>
			<source ref="id98"/>
			<target ref="id102"/>
			<label kind="synchronisation" x="-816" y="-578">disconnected[id]?</label>
			<nail x="-697" y="-552"/>
			<nail x="-952" y="-552"/>
		</transition>
		<transition>
			<source ref="id98"/>
			<target ref="id102"/>
			<label kind="synchronisation" x="-833" y="-612">stop_sample[id]?</label>
			<nail x="-722" y="-586"/>
		</transition>
		<transition>
			<source ref="id101"/>
			<target ref="id98"/>
			<label kind="guard" x="-688" y="-799">x &gt;= uart_latency</label>
			<label kind="synchronisation" x="-688" y="-782">sample_ready[id]!</label>
			<label kind="assignment" x="-688" y="-756">x = 0,
samples_ready[id] = 1</label>
			<nail x="-697" y="-756"/>
		</transition>
		<transition>
			<source ref="id99"/>
			<target ref="id101"/>
			<label kind="guard" x="-408" y="-722">x &gt;= codec_latency</label>
			<label kind="assignment" x="-408" y="-705">x = 0</label>
		</transition>
		<transition>
			<source ref="id102"/>
			<target ref="id100"/>
			<label kind="assignment" x="-994" y="-629">x = 0</label>
		</transition>
		<transition>
			<source ref="id100"/>
			<target ref="id98"/>
			<label kind="synchronisation" x="-910" y="-688">sample[id]?</label>
			<label kind="assignment" x="-910" y="-671">x = 0,
bs = getBS(id)</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
usr_1 = UserStates(0, 5000);
usr_1c = UserConnect(0);
usr_1j = UserJoined(0);
usr_1lt = UserListenOnly(0);
usr_1s = UserStream(0, 1);
usr_1sm = UserSample(0, 48, 16);

usr_2 = UserStates(1, 0);
usr_2c = UserConnect(1);
usr_2j = UserJoined(1);
usr_2lt = UserListenOnly(1);
usr_2s = UserStream(1, 1);
usr_2sm = UserSample(1, 48, 16);

bs_1 = BaseStation(0);
bs_1clk = FrameClock(0);
bs_1s = Scheduler(0);
bs_1ip = InternalProcessing(0, 6250);

bs_2 = BaseStation(1);
bs_2clk = FrameClock(1);
bs_2s = Scheduler(1);
bs_2ip = InternalProcessing(1, 6250);

// List one or more processes to be composed into a system.
system bs_1, bs_1clk, bs_1s, bs_1ip, bs_2, bs_2clk, bs_2s, bs_2ip, usr_1, usr_1s, usr_1c, usr_1j, usr_1lt, usr_1sm;
    </system>
	<queries>
		<query>
			<formula>E&lt;&gt; ( bs_1.TRANSMIT_BCH and bs_1s.INITIAL and bs_1ip.INITIAL and bs_2.TRANSMIT_BCH and bs_2s.INITIAL and bs_2ip.INITIAL and usr_1.ON and usr_1s.INITIAL and usr_1c.INITIAL and usr_1j.INITIAL and usr_1lt.INITIAL and usr_1sm.INITIAL )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>E&lt;&gt; ( bs_1.GUARD and bs_1clk.FRAME_TIME and bs_1s.INITIAL and bs_1ip.INITIAL and bs_2.GUARD and bs_2clk.FRAME_TIME and bs_2s.INITIAL and bs_2ip.INITIAL and usr_1.CONNECTING and usr_1s.INITIAL and usr_1c.TEST_CHANNEL and usr_1j.INITIAL and usr_1lt.INITIAL and usr_1sm.INITIAL )</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>simulate [&lt;= 400000; 1] {bs_2.channel, bs_2.prob_success, bs_2.prob_failure}</formula>
			<comment></comment>
		</query>
		<query>
			<formula>simulate [&lt;= 40000; 1] {frame_clk[0], bs_1.INITIAL, bs_1.TRANSMISSION + 4}</formula>
			<comment></comment>
		</query>
		<query>
			<formula>simulate [&lt;= 800000; 1] {bs_2s.RETRY, frame_clk[0]}</formula>
			<comment></comment>
		</query>
		<query>
			<formula>simulate [&lt;= 400000; 1] {samples_lost[0]}</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] not bs_1s.UNSCHEDULABLE</formula>
			<comment>Frame must always be schedulable.</comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.RETRY</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.RETRANSMISSION</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.FINISHED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.STARTED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.NEXT_SLOT</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.PROCESS_INTERNAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.PROCESS_QCA</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.UL_NACK</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.UL_ACK</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.WAIT_SLOT</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.WAIT_UL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.GUARD</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.RETRANSMISSION</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.SWITCH_CHANNEL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.TRANSMIT_BCH</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.READY</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.WAIT_READY</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.PREPARE</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.TRANSMISSION</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1ip.PROCESS_CENTRAL_BASE</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1ip.DECODE_AUDIO</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1ip.TRANSFER_AES</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1ip.PROCESS_INTERNAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1ip.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1lt.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.BCH_ACK</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.WAIT_BCH</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.TEST_CHANNEL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.SCAN</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.INIT</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.CONNECTING</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] not usr_1.DISCONNECTED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.JOINED</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
	</queries>
</nta>
