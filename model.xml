<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>
// Place global declarations here.

// --------------------------------------------------------------------------------------------
// GLOBAL CONSTANTS
// Provides supported system capacity, number of active users, time units, frame information
// --------------------------------------------------------------------------------------------

// In this model time is measured in us, it can be further atomized changing the
// unit value, e.g. to 10, 100, 1000
const int unit = 1;    // time unit ratio wrt 1 us

clock frame_clk;    // frame clock timer

const int number_BS = 2;    // number of Base Stations
typedef int [0, number_BS - 1] BSid_t;

const int number_UE = 10;    // number of User Equipment
typedef int [0, number_UE - 1] UEid_t;

const int number_profiles = 5;    // number of UE profiles
typedef int [0, number_profiles - 1] profileId_t;

const profileId_t initial = 0;        // Initial connected mode
const profileId_t Listen_Only = 1;    // Listen-Only
const profileId_t sRTa = 2;           // Sporadic Real-Time Audio
const profileId_t RTa = 3;            // Real-Time Audio
const profileId_t HqRTa = 4;          // High-Quality Real-Time Audio

typedef int[-(1&lt;&lt;23),(1&lt;&lt;23)-1] int24_t;
const int latency[profileId_t] = {-1, 2500, 70, 40, 20};    // latency requirements of each type of profiles

// --------------------------------------------------------------------------------------------
// INITIAL CASE
// Static and equal slot size for all nodes
// A beacon slot of static size in the end of the frame
// --------------------------------------------------------------------------------------------

const int MCS = 3;    // MCS index

const int channel_bandwidth = 40;    // MHz

const int data_rate = 60;    // Mbit/s

const int GI = 400;    // us

const int audio_quality = 48;    // kbits/s

const int bit_depth = 16;    // bits

int number_GIs = 2;    // initial number of GI spaces

int GI_size;    // us

profileId_t static_profile[UEid_t] = {3, 3, 3, 3, 3, 3, 3, 1, 1, 1};

typedef int [0, number_UE] slotID_t;

int owner[BSid_t][slotID_t] = {
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

int slot_start[BSid_t][slotID_t] = {    // start times of dedicated TCH slots for the nodes in current frame + RACH
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

int slot_size[BSid_t][slotID_t] = {    // sizes of dedicated TCH slots for the nodes in current frame + RACH (ms * unit)
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

int24_t slot_data[BSid_t][slotID_t] = {    // data sizes of dedicated TCH slots in current frame + RACH (in kbits)
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

// --------------------------------------------------------------------------------------------
// Initial variables of the system
// --------------------------------------------------------------------------------------------

profileId_t profile[UEid_t] = {4, 1, 2, 3, 4, 2, 0, 1, 2, 3};    // initial profiles of the UEs - can be negotiated with the BS

const int frame_size[BSid_t] = {latency[RTa] * 1000 * unit, latency[RTa] * 1000 * unit};    // initial frame size (us * unit)

// --------------------------------------------------------------------------------------------
// UE INITIAL
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan started[UEid_t];    // UE start signal

const int offset_used = -1;    // offset ID used (-1: using default)

const int offsets[2][UEid_t] =
{
    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
    {10, 20, 5, 0, 10, 40, 7, 15, 30, 0}
};

// VARIABLES ----------------------------------------------------------------------------------

int start_offsets[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // default offset of UE start signal

int BS_assignment[UEid_t] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};    // initial association with the BS

// FUNCTIONS ----------------------------------------------------------------------------------

int getBS(UEid_t id)
{
    return BS_assignment[id];
}

void setOffset()    // setting offset values from possible variations in offsets
{
    if(offset_used != -1)
        for(i: UEid_t) start_offsets[i] = offsets[offset_used][i] * unit;
}

// --------------------------------------------------------------------------------------------
// UE CONNECT
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan connected[UEid_t];    // UE connected signal

broadcast chan disconnected[UEid_t];    // UE disconnected signal

broadcast chan failed[UEid_t];    // UE signal for failed latency requirements

broadcast chan RACH[BSid_t];    // UE signal to BS through the random access channel in order to connect

const int disconnect_timeout = 5000 * 1000 * unit;    // timeout for disconnect in us

// VARIABLES ----------------------------------------------------------------------------------

// connection channel stability
int connection_channel_stability[UEid_t][2] =
{
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75}
};

int RACH_slot = number_UE;

int RACH_start = 0;    // start time of random access channel in the current frame

int RACH_size = 0;  // size of random access channel slots (us * unit)

int RACH_id = -1;    // UE id which sends RACH signal in the current RACH slot

// --------------------------------------------------------------------------------------------
// LISTEN_ONLY
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

const int number_channels = 10;    // number of hard-coded channel frequencies to scan through

const int channels[number_channels] = {1500, 1800, 2000, 2200, 2300, 2400, 3100, 3500, 4200, 5000};    // channel frequencies (kHz) to scan for BS down-link reception

broadcast chan BCH[number_channels];    // broadcast channel

broadcast chan listen[UEid_t];    // UE to set Listen-Only mode signal

broadcast chan sleep[UEid_t];    // UE signal for RF module to sleep

broadcast chan wake_up[UEid_t];    // UE signal for RF module to wake-up

broadcast chan UCCH[BSid_t][slotID_t];    // Up-Link control channel

// VARIABLES ----------------------------------------------------------------------------------

// int BCH_duration = 5;    // initial BCH transmission duration

// initial channel interference probability
int channel_interference_probability[UEid_t][2] =
{
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75},
    {25, 75}
};

// --------------------------------------------------------------------------------------------
// TODO
//
// Channel interference probability is transmission success probability. It must be calculated to
// depend on the UE distance from the BS and used MCS - the error correction level
// --------------------------------------------------------------------------------------------

bool ACK[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // BS acknowledge of the initial UL resource request from the UE

int sleep_time[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // RRM (Radio Resource Manager) calculated sleep time for UE after receiving UL ACKs

// --------------------------------------------------------------------------------------------
// STREAM
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan stream[UEid_t];    // UE signal to start audio streaming

broadcast chan sample[UEid_t];    // UE signal to DSP to start audio sampling

broadcast chan stop_sample[UEid_t];    // UE signal to DSP to stop audio sampling (in case of mode changes)

broadcast chan sample_ready[UEid_t];    // UE signal from DSP that a new audio sample is ready loaded in the memory

broadcast chan UTCH[BSid_t][slotID_t];    // up-link UE signal to BS transmitting audio data

// VARIABLES ----------------------------------------------------------------------------------

int samples_ready[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // audio samples ready to be read from memory

int samples_lost[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // audio samples that were lost because of moving relevant sample window

// FUNCTIONS ----------------------------------------------------------------------------------

int24_t getLatency(UEid_t id)
{
    return latency[static_profile[id]] * 1000;
}

//double dsp_to_qca(){
//    return (frame_size/1000 * audio_data_rate)/uart_speed;
//}

// --------------------------------------------------------------------------------------------
// QUEUE
// --------------------------------------------------------------------------------------------

typedef struct {
    int prior;    // priority identification (depending on QoS and CQI)
    UEid_t id;    // UE's ID
} Node_t;

typedef struct {
    int front;
    int rear;
    int size;
    Node_t queue[UEid_t];
} Queue_t;

bool isEmpty(Queue_t q){
    return q.size &lt;= 0;
}

bool isFull(Queue_t q)
{
    return q.size == number_UE;
}

int getSize(Queue_t q)
{
    return q.size;
}

Node_t getFirst(Queue_t q)
{
    return q.queue[q.front];
}

Node_t getLast(Queue_t q)
{
    return q.queue[q.rear];
}

int insert(Node_t value, Queue_t &amp;q)    // add a node according to its priority
{
    int i = 0;
    bool found = false;

    if(!isFull(q)){
        if(isEmpty(q))
        {
            q.queue[++q.size] = value;
            q.front = q.rear = 0;
        }
        else
        {
            for(i = q.size-1; i &gt;= 0; i--)
            {
                if(value.prior &gt; q.queue[i].prior &amp;&amp; !found)
                {
                    q.queue[i+1] = q.queue[i];
                    found = true;
                }
            }
            q.queue[i] = value;
            q.size++;
        }
        return 0;
    }
    else
    {
        // Queue is full
        return -1;
    }
}

int enqueue(Node_t value, Queue_t &amp;q)    // add a node at the end of the queue
{
    if(q.size &lt; number_UE)
    {
        if(isEmpty(q))
        {
            q.queue[0] = value;
            q.front = q.rear = 0;
            q.size = 1;
        }
        else if(q.rear == number_UE - 1)
        {
            q.queue[0] = value;
            q.rear = 0;
            q.size++;
        }
        else
        {
            q.queue[q.rear + 1] = value;
            q.rear++;
            q.size++;
        }
        return 0;
    }
    else
    {
        // Queue is full
        return -1;
    }
}

int pop(Queue_t q)
{
    if(isEmpty(q))
    {
        // Queue is empty
        return -1;
    }
    else
    {
        Node_t value = getLast(q);
        q.size--;
        q.rear--;
        return value.id;
    }
}

int dequeue(Queue_t q)
{

    if(isEmpty(q))
    {
        // Queue is empty
        return -1;
    }
    else
    {
        Node_t value = getFirst(q);
        q.size--;
        q.front++;
        return value.id;
    }
}

// --------------------------------------------------------------------------------------------
// BASE STATION
// --------------------------------------------------------------------------------------------

// CONSTANTS ----------------------------------------------------------------------------------

broadcast chan schedule[BSid_t];    // BS signal to execute radio resource scheduling

broadcast chan frame_start[BSid_t];    // RRM signal to BS that scheduling is done

broadcast chan retransmit_ready[BSid_t];    // RRM signal to BS that retransmission scheduling is done

broadcast chan processing[BSid_t];    // BS QCA signal to DSP to internally process data

const int broadcast_channel[BSid_t] = {2, 7};    // BCH transmission channel frequencies (kHz)

const int retransmission_channel[BSid_t] = {4, 9};    // BCH retransmission channel frequencies (kHz)

const int channel_switch = 244 * unit;    // frequency change latency

// VARIABLES ----------------------------------------------------------------------------------

int bch_interference_probability[BSid_t][2] =
{
    {10, 90},
    {10, 90}
};

bool retransmission[BSid_t] = {false, false};

int number_slots = 0;    //  UTCHs, UCCHs and RACH

Queue_t priority_queue[BSid_t] =    // Queue of active devices with profiles RTa, hqRTa and sRTA
{
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}},
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}}
};

Queue_t request_queue[BSid_t] =    // Queue of active devices in connected and Listen-Only modes
{
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}},
    {-1, -1, -1, {{-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}, {-1, 0}}}
};

bool active_UE[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // identification of UE that are active

bool listen_only_UE[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // identification of UE that are in Listen-Only mode

bool connected_UE[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // identification of UE that are in initial connected mode

int UE_CQI[UEid_t] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};    // channel quality indications of all active UE

int current_slot[BSid_t] = {-1, -1};

bool DSP_status[BSid_t] = {true, true};    // DSP processing status (ongoing - 0, done - 1)

int maxBSProcessTime;

int maxUEProcessTime;

// FUNCTIONS ----------------------------------------------------------------------------------

int getActive()
{
    int counter = 0;
    for(i: UEid_t)
    {
        if(active_UE[i])
            counter++;
    }
    return counter;
}

int getListeners()
{
    int counter = 0;
    for(i: UEid_t)
    {
        if(listen_only_UE[i])
            counter++;
    }
    return counter;
}

int getConnected()
{
    int counter = 0;
    for(i: UEid_t)
    {
        if(listen_only_UE[i])
            counter++;
    }
    return counter;
}

// --------------------------------------------------------------------------------------------

// Note: max capacity of BCH headers is 40 Bytes

// frame-based sampling approach for the initial case
int BCH_meta_bits;
int BCH_slot_audio_bits;
int getBCHDuration(BSid_t bs)    // in us
{
    int BCH_slot_meta_bits = 5 * 8;
    //                              in us
    BCH_meta_bits = (((512 * 1024)/frame_size[bs]/8) + 64) * 8;
    //                                                   in us
    BCH_slot_audio_bits = (audio_quality/1000) * frame_size[bs] + BCH_slot_meta_bits;
    return (BCH_meta_bits + (BCH_slot_meta_bits + BCH_slot_audio_bits) * getActive() + (BCH_slot_meta_bits + BCH_slot_audio_bits) * getListeners() + BCH_slot_meta_bits * getConnected())/data_rate;
}

int getULMetaData()
{
    return 20 * 8;
}

int getULMetaDuration()    // in us
{
    return getULMetaData()/data_rate;
}

int getULAudioData(BSid_t bs)
{
    return (audio_quality/1000) * frame_size[bs] + getULMetaData();
}

int getULAudioDuration(BSid_t id)    // in us
{
    return getULAudioData(id)/data_rate;
}

int getRACHData()
{
    return 176 * 8;
}

int getRACHDuration()    // in us
{
    return getRACHData()/data_rate;
}

// --------------------------------------------------------------------------------------------

void add_UE(BSid_t bs, UEid_t id)
{
    Node_t new_node = {-1, id};
    ACK[id] = true;
    if(profile[id] == initial)
    {
        connected_UE[id] = true;
    }
    else if(profile[id] == Listen_Only)
    {
        listen_only_UE[id] = true;
    }
    else
    {
        active_UE[id] = true;
        //new_node.prior = profile[id];
        //insert(new_node, priority_queue[bs]);
        return;
    }
    //enqueue(new_node, request_queue[bs]);
}

</declaration>
	<template>
		<name>BaseStationDSP</name>
		<parameter>BSid_t id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int AES_bit_clock = 12288;    // kHz

const int internal_processing = 50;    // us

const int cb_processing = 50;    // audio data processing time in central base (in us)

const int decode_time = 1/(44000 * 1000000);    // audio decoding time (in us)

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // general utility timer

bool isAudio = false;

int aes_transmit = 0;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int getAESTime()
{
    return getULAudioData(id)/(AES_bit_clock/1000);
}

int getDataType()
{
    int i = owner[id][current_slot[id]];
    if(i &gt; number_UE &amp;&amp; static_profile[i] == RTa)
        return true;
    return false;
}

// --------------------------------------------------------------------------------------------
// TODO
// Is 44000 value in audio decoding always static and what it refers to?
// Can the same DSP template be used for both BS and UE?
// --------------------------------------------------------------------------------------------</declaration>
		<location id="id0" x="-569" y="-306" color="#ffffff">
			<name x="-629" y="-314">INITIAL</name>
		</location>
		<location id="id1" x="-569" y="-229" color="#ff00ff">
			<name x="-731" y="-246">PROCESS_INTERNAL</name>
			<label kind="invariant" x="-739" y="-229">x &lt;= internal_processing</label>
		</location>
		<location id="id2" x="-187" y="-229">
			<name x="-170" y="-246">TRANSFER_AES</name>
			<label kind="invariant" x="-170" y="-229">x &lt;= aes_transmit</label>
			<label kind="comments" x="-42" y="-238">To Central Base</label>
		</location>
		<location id="id3" x="-187" y="-399" color="#ff00ff">
			<name x="-170" y="-416">DECODE_AUDIO</name>
			<label kind="invariant" x="-170" y="-399">x &lt;= decode_time</label>
		</location>
		<location id="id4" x="-357" y="-229">
			<urgent/>
		</location>
		<location id="id5" x="-569" y="-399" color="#ff00ff">
			<name x="-663" y="-450">PROCESS_CENTRAL_BASE</name>
			<label kind="invariant" x="-620" y="-433">x &lt;= cb_processing</label>
		</location>
		<init ref="id0"/>
		<transition>
			<source ref="id5"/>
			<target ref="id0"/>
			<label kind="guard" x="-561" y="-382">x &gt;= cb_processing</label>
			<label kind="assignment" x="-561" y="-365">x = 0,
DSP_status[id] = 1</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="guard" x="-348" y="-433">x &gt;= decode_time</label>
			<label kind="assignment" x="-348" y="-416">x = 0</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id0"/>
			<label kind="guard" x="-348" y="-306">!isAudio</label>
			<label kind="assignment" x="-348" y="-289">x = 0,
DSP_status[id] = 1</label>
			<nail x="-357" y="-306"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="guard" x="-178" y="-331">x &gt;= aes_transmit</label>
			<label kind="assignment" x="-178" y="-314">x = 0</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="-331" y="-229">isAudio</label>
			<label kind="assignment" x="-331" y="-212">x = 0,
aes_transmit = getAESTime()</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="guard" x="-535" y="-229">x &gt;= internal_processing</label>
			<label kind="assignment" x="-535" y="-212">x = 0,
isAudio = getDataType()</label>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-561" y="-297">processing[id]?</label>
			<label kind="assignment" x="-561" y="-280">x = 0,
DSP_status[id] = 0</label>
		</transition>
	</template>
	<template>
		<name>Scheduler</name>
		<parameter>BSid_t id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

bool success = false;    // Successful scheduling indication

int disconnect_UE = -1;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int scheduleRF()
{
    bool new_entrants = false;
    for(i: UEid_t)
    {
        if(ACK[i])
        {
            new_entrants = true;
        }
    }
    if(!success || new_entrants)
    {
        int j = 0;
        int BCH_end;
        int slot_count;    // BCH, UTCHs, UCCHs and RACH
        int start_time = 0;
        int transmission_duration = frame_size[id]/2;
        int UL_duration = getULAudioDuration(id) * getActive() + getULMetaDuration() * (getListeners() + getConnected());

        maxUEProcessTime = 50 + (1/44000*1000000) + getULAudioData(id)/1;
        BCH_end = channel_switch + getBCHDuration(id);
        RACH_size = getRACHDuration();
        number_slots = getActive() + getListeners() + 1;
        slot_count = 2 + number_slots;
        GI_size = (transmission_duration - (BCH_end + UL_duration + RACH_size))/slot_count;

        // Preparation time for the UL verification
        // Making sure time it takes from samples ready to transmission ready is smaller
        // than the start of the UL slot
        if(maxUEProcessTime &gt; BCH_end + GI_size)
        {
            return 1;
        }

        // GI verification
        if(GI_size &lt; GI)    // actual GI size must be &gt;= of GI required by MCS used
        {
            // drop Listen-Only node and re-evaluate
            for(i: UEid_t)
            {
                if(listen_only_UE[i])
                {
                    disconnect_UE = i;
                    return 0;
                }
            }
            // drop streaming node and re-evaluate, if no Listen-Only nodes available
            for(i: UEid_t)
            {
                if(active_UE[i])
                {
                    disconnect_UE = i;
                    return 0;
                }
            }
            disconnect_UE = -1;    // unschedulable - erroneous frame setup
            return 0;
        }

        // slot start calculation
        start_time = BCH_end + GI_size;
        for(i: UEid_t)
        {
            if(active_UE[i])
            {
                owner[id][j++] = i;
                slot_size[id][i] = getULAudioDuration(id);
                slot_data[id][i] = getULAudioData(id);
                slot_start[id][i] = start_time;
                start_time = slot_start[id][i] + slot_size[id][i]  + GI_size;
            }
        }
        for(i: UEid_t)
        {
            if(listen_only_UE[i])
            {
                owner[id][j++] = i;
                slot_size[id][i] = getULMetaDuration();
                slot_data[id][i] = getULMetaData();
                slot_start[id][i] = start_time;
                start_time = slot_start[id][i] + slot_size[id][i] + GI_size;
            }
        }
        for(i: UEid_t)
        {
            if(connected_UE[i])
            {
                owner[id][j++] = i;
                slot_size[id][i] = getULMetaDuration();
                slot_data[id][i] = getULMetaData();
                slot_start[id][i] = start_time;
                start_time = slot_start[id][i] + slot_size[id][i] + GI_size;
            }
        }
        owner[id][j++] = number_UE;
        slot_size[id][number_UE] = RACH_size;
        slot_data[id][number_UE] = getRACHData();
        slot_start[id][number_UE] = start_time;
        RACH_start = start_time;
    }
    return 1;
}

// --------------------------------------------------------------------------------------------
// TODO
// in the ACK enabled version: reset the ACK
// --------------------------------------------------------------------------------------------
</declaration>
		<location id="id6" x="-841" y="-519" color="#ffffff">
			<name x="-851" y="-553">INITIAL</name>
		</location>
		<location id="id7" x="-841" y="-374">
			<name x="-918" y="-399">STARTED</name>
			<urgent/>
		</location>
		<location id="id8" x="-603" y="-280">
			<name x="-628" y="-263">FINISHED</name>
			<urgent/>
		</location>
		<location id="id9" x="-1028" y="-374">
			<name x="-1088" y="-357">RETRANSMISSION</name>
			<label kind="comments" x="-1130" y="-331">Retransmission uses the same
schedule as original transmission -
no need for extra scheduling.</label>
			<urgent/>
		</location>
		<location id="id10" x="-603" y="-425">
			<name x="-620" y="-459">RETRY</name>
			<urgent/>
		</location>
		<location id="id11" x="-782" y="-374">
			<name x="-817" y="-408">UNSCHEDULABLE</name>
			<urgent/>
		</location>
		<init ref="id6"/>
		<transition>
			<source ref="id9"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-1020" y="-544">retransmit_ready[id]!</label>
			<label kind="assignment" x="-1020" y="-518">frame_clk = 0</label>
			<nail x="-1028" y="-518"/>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id7"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id11"/>
			<label kind="guard" x="-756" y="-374">disconnect_UE == -1</label>
			<nail x="-620" y="-374"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id7"/>
			<label kind="guard" x="-816" y="-468">disconnect_UE != -1</label>
			<label kind="synchronisation" x="-816" y="-451">disconnected[disconnect_UE]!</label>
			<nail x="-817" y="-425"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id10"/>
			<label kind="guard" x="-603" y="-340">!success</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id9"/>
			<label kind="guard" x="-986" y="-374">retransmission[id]</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="guard" x="-637" y="-561">success</label>
			<label kind="synchronisation" x="-637" y="-544">frame_start[id]!</label>
			<label kind="assignment" x="-637" y="-518">frame_clk = 0</label>
			<nail x="-536" y="-279"/>
			<nail x="-536" y="-518"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="guard" x="-790" y="-306">!retransmission[id]</label>
			<label kind="assignment" x="-790" y="-281">success = scheduleRF()</label>
			<nail x="-841" y="-280"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-926" y="-459">schedule[id]?</label>
		</transition>
	</template>
	<template>
		<name>BaseStation</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int qca_processing = 25;    // QCA processing time (in us)

const int uart_speed = 6250;    // uart transmission speed (in kbit/s)

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // general utility timer

int channel;    // BS DL channel

int slot = 0;    // slot counter during the frame execution

UEid_t new = 0;    // ID of current slot's owner (UE)

int prob_failure;
int prob_success;

int BCH_duration;

int uart_latency = 0;

bool success[slotID_t] = {false, false, false, false, false, false, false, false, false, false, false};

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_success = connection_channel_stability[id][1];
    prob_failure = connection_channel_stability[id][0];
}

int getUARTTime()
{
    int uart_transfer = getULAudioData(id)/(uart_speed/1000);
    maxBSProcessTime = qca_processing + uart_transfer;
    return uart_transfer;
}

// --------------------------------------------------------------------------------------------
// TODO
// Does processing of a UL slot data happens right after each UL and before the next one is
// going to be received? The same question reharding the UE.
// --------------------------------------------------------------------------------------------
</declaration>
		<location id="id12" x="-842" y="-1012" color="#ffffff">
			<name x="-867" y="-1045">INITIAL</name>
			<urgent/>
		</location>
		<location id="id13" x="-170" y="-850">
			<name x="-153" y="-867">READY</name>
			<urgent/>
		</location>
		<location id="id14" x="-170" y="-765" color="#6c3483">
			<name x="-212" y="-748">TRANSMIT_BCH</name>
			<label kind="invariant" x="-238" y="-730">frame_clk &lt;= BCH_duration</label>
		</location>
		<location id="id15" x="-841" y="-518" color="#ffa500">
			<name x="-824" y="-535">WAIT_UL</name>
			<label kind="invariant" x="-824" y="-518">x &lt;= slot_size[id][owner[id][slot]]</label>
		</location>
		<location id="id16" x="-842" y="-850">
			<urgent/>
		</location>
		<location id="id17" x="-1139" y="-357" color="#00ff00">
			<name x="-1164" y="-341">UL_ACK</name>
			<urgent/>
		</location>
		<location id="id18" x="-1139" y="-518" color="#00ffff">
			<name x="-1165" y="-501">UL_NACK</name>
			<urgent/>
		</location>
		<location id="id19" x="-1139" y="-765">
			<name x="-1181" y="-799">NEXT_SLOT</name>
			<urgent/>
		</location>
		<location id="id20" x="-842" y="-927">
			<name x="-960" y="-943">TRANSMISSION</name>
			<label kind="invariant" x="-901" y="-926">x' == 0</label>
			<urgent/>
		</location>
		<location id="id21" x="-502" y="-850" color="#ffff00">
			<name x="-484" y="-875">RETRANSMISSION</name>
			<urgent/>
		</location>
		<location id="id22" x="-842" y="-764">
			<name x="-824" y="-756">GUARD</name>
			<label kind="invariant" x="-824" y="-739">x' == 1 &amp;&amp;
x &lt;= GI_size</label>
		</location>
		<location id="id23" x="-680" y="-850">
			<name x="-731" y="-901">SWITCH_CHANNEL</name>
			<label kind="invariant" x="-731" y="-884">x &lt;= channel_switch</label>
		</location>
		<location id="id24" x="-841" y="-637" color="#ffa500">
			<name x="-824" y="-662">WAIT_SLOT</name>
			<label kind="invariant" x="-824" y="-645">frame_clk &lt;=
slot_start[id][owner[id][slot]]</label>
		</location>
		<location id="id25" x="-1385" y="-357" color="#ff00ff">
			<name x="-1512" y="-366">PROCESS_QCA</name>
			<label kind="invariant" x="-1538" y="-349">x &lt;= qca_processing</label>
		</location>
		<location id="id26" x="-1334" y="-561" color="#ff00ff">
			<name x="-1308" y="-569">PROCESS_INTERNAL</name>
			<urgent/>
		</location>
		<location id="id27" x="-323" y="-926" color="#ffa500">
			<name x="-365" y="-960">WAIT_READY</name>
		</location>
		<location id="id28" x="-501" y="-926" color="#ff00ff">
			<name x="-535" y="-960">PREPARE</name>
			<urgent/>
		</location>
		<location id="id29" x="-1385" y="-561" color="#8e5f53">
			<name x="-1436" y="-570">BUSY</name>
			<label kind="comments" x="-1708" y="-586">Retransmission needed as data
could not be processed due to
busy DSP devices.</label>
			<urgent/>
		</location>
		<location id="id30" x="-1385" y="-765" color="#4e342e">
			<name x="-1453" y="-774">FAILED</name>
			<urgent/>
		</location>
		<location id="id31" x="-1385" y="-459">
			<name x="-1479" y="-476">TRANSFER</name>
			<label kind="invariant" x="-1513" y="-459">x &lt;= uart_latency</label>
			<label kind="comments" x="-1691" y="-467">QCA to host processor</label>
		</location>
		<branchpoint id="id32" x="-484" y="-765">
		</branchpoint>
		<init ref="id12"/>
		<transition>
			<source ref="id25"/>
			<target ref="id31"/>
			<label kind="assignment" x="-1377" y="-416">x = 0,
uart_latency = getUARTTime()</label>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id19"/>
			<label kind="guard" x="-1326" y="-739">!retransmission[id]</label>
			<label kind="assignment" x="-1326" y="-722">success[slot] = 0</label>
			<nail x="-1326" y="-722"/>
			<nail x="-1164" y="-722"/>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id19"/>
			<label kind="assignment" x="-1377" y="-816">samples_lost[owner[id][slot]] =
samples_ready[owner[id][slot]]</label>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id30"/>
			<label kind="guard" x="-1521" y="-671">retransmission[id] &amp;&amp;
!success[slot]</label>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id29"/>
			<label kind="guard" x="-1513" y="-527">!DSP_status[id] &amp;&amp;
x &gt;= uart_latency</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id28"/>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id13"/>
			<label kind="synchronisation" x="-314" y="-875">retransmit_ready[id]?</label>
			<nail x="-323" y="-850"/>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id13"/>
			<label kind="synchronisation" x="-272" y="-952">frame_start[id]?</label>
			<nail x="-170" y="-926"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id19"/>
			<label kind="assignment" x="-1292" y="-663">success[slot] = 1</label>
			<nail x="-1300" y="-663"/>
			<nail x="-1173" y="-663"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id26"/>
			<label kind="guard" x="-1326" y="-527">DSP_status[id] &amp;&amp;
x &gt;= uart_latency</label>
			<label kind="synchronisation" x="-1326" y="-484">processing[id]!</label>
			<nail x="-1334" y="-459"/>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="-688" y="-748">BCH[channel]!</label>
			<label kind="probability" x="-688" y="-765">prob_success</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id15"/>
			<label kind="guard" x="-833" y="-595">frame_clk &gt;= slot_start[id][owner[id][slot]]</label>
			<label kind="assignment" x="-833" y="-578">x = 0</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id21"/>
			<label kind="guard" x="-663" y="-841">x &gt;= channel_switch</label>
			<label kind="assignment" x="-663" y="-824">x = 0,
channel = retransmission_channel[id]</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id24"/>
			<label kind="guard" x="-977" y="-731">x &gt;= GI_size &amp;&amp;
slot &lt; number_slots</label>
			<label kind="assignment" x="-977" y="-688">current_slot[id] = slot</label>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id28"/>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-450" y="-952">schedule[id]!</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id23"/>
			<label kind="guard" x="-816" y="-850">retransmission[id]</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id20"/>
			<label kind="guard" x="-969" y="-909">!retransmission[id]</label>
			<label kind="assignment" x="-1054" y="-892">channel = broadcast_channel[id]</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id16"/>
			<label kind="guard" x="-977" y="-841">x &gt;= GI_size &amp;&amp;
slot &gt;= number_slots</label>
			<label kind="assignment" x="-1088" y="-824">x = 0,
retransmission[id] = !retransmission[id]</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id17"/>
			<label kind="guard" x="-833" y="-408">owner[id][slot] == RACH_slot</label>
			<label kind="synchronisation" x="-833" y="-391">RACH[id]?</label>
			<label kind="assignment" x="-833" y="-374">add_UE(id, RACH_id)</label>
			<nail x="-842" y="-357"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id19"/>
			<label kind="assignment" x="-1130" y="-603">x = 0</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id25"/>
			<label kind="assignment" x="-1317" y="-357">x = 0,
RACH_id = -1</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id22"/>
			<label kind="assignment" x="-1113" y="-765">slot += 1,
x = 0</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id18"/>
			<label kind="guard" x="-1088" y="-544">x &gt;= slot_size[id][owner[id][slot]]</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-1062" y="-425">UTCH[id][owner[id][slot]]?</label>
			<nail x="-901" y="-399"/>
			<nail x="-1088" y="-399"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-1096" y="-467">UCCH[id][owner[id][slot]]?</label>
			<nail x="-943" y="-442"/>
			<nail x="-1105" y="-442"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id32"/>
			<label kind="guard" x="-450" y="-765">frame_clk &gt;= BCH_duration</label>
			<label kind="assignment" x="-450" y="-748">getProbability(),
slot = 0,
x = 0</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id14"/>
			<label kind="assignment" x="-399" y="-816">BCH_duration = getBCHDuration(id)</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id20"/>
			<label kind="assignment" x="-1054" y="-986">channel = broadcast_channel[id]</label>
		</transition>
	</template>
	<template>
		<name>UserListenOnly</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int qca_latency = 50;    // QCA processing time (in us)

const int uart_speed = 1000;    // uart transmission speed (in kbit/s)

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // latency timer
clock z;    // disconnect timer

int bs;    // BS that this UE is connected to
int channel;    // BS DL channel

int prob_failure;
int prob_success;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_failure = channel_interference_probability[id][0];
    prob_success = channel_interference_probability[id][1];
}</declaration>
		<location id="id33" x="-1836" y="-1495" color="#ffffff">
			<name x="-1904" y="-1513">INITIAL</name>
			<label kind="invariant" x="-1912" y="-1496">x' == 0 &amp;&amp;
z' == 0</label>
		</location>
		<location id="id34" x="-1198" y="-1496" color="#138d75">
			<name x="-1223" y="-1480">BCH_ACK</name>
			<label kind="invariant" x="-1223" y="-1463">z' == 0</label>
			<urgent/>
		</location>
		<location id="id35" x="-1198" y="-1683" color="#ffa500">
			<name x="-1240" y="-1734">WAIT_SLOT</name>
			<label kind="invariant" x="-1282" y="-1717">frame_clk &lt;= slot_start[bs][id]</label>
		</location>
		<location id="id36" x="-1513" y="-1385" color="#3498db">
			<name x="-1496" y="-1402">BCH_NACK</name>
			<urgent/>
		</location>
		<location id="id37" x="-1667" y="-1496" color="#ffa500">
			<name x="-1751" y="-1555">WAIT_BCH</name>
			<label kind="invariant" x="-1751" y="-1538">x &lt;= getLatency(id) &amp;&amp;
z &lt;= disconnect_timeout</label>
		</location>
		<location id="id38" x="-1666" y="-1385" color="#4e342e">
			<name x="-1717" y="-1402">FAIL</name>
			<label kind="invariant" x="-1725" y="-1385">z' == 1</label>
			<urgent/>
		</location>
		<location id="id39" x="-1666" y="-1683" color="#4e342e">
			<name x="-1707" y="-1718">DISCONNECT</name>
			<urgent/>
		</location>
		<location id="id40" x="-1453" y="-1683" color="#6c3483">
			<name x="-1487" y="-1734">TRANSMIT</name>
			<label kind="invariant" x="-1512" y="-1717">x &lt;= slot_size[bs][id]/2</label>
		</location>
		<location id="id41" x="-1198" y="-1589" color="#ff00ff">
			<name x="-1283" y="-1598">PREPARE</name>
			<label kind="comments" x="-1190" y="-1632">Already taken into account in scheduling phase</label>
			<urgent/>
		</location>
		<branchpoint id="id42" x="-1453" y="-1614">
		</branchpoint>
		<init ref="id33"/>
		<transition>
			<source ref="id34"/>
			<target ref="id41"/>
			<label kind="guard" x="-1139" y="-1496">retransmission[bs]</label>
			<label kind="assignment" x="-1139" y="-1479">channel = retransmission_channel[bs]</label>
			<nail x="-1028" y="-1496"/>
			<nail x="-1028" y="-1589"/>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id35"/>
		</transition>
		<transition>
			<source ref="id42"/>
			<target ref="id37"/>
			<label kind="synchronisation" x="-1445" y="-1589">UCCH[bs][id]!</label>
			<label kind="assignment" x="-1445" y="-1572">x = 0</label>
			<label kind="probability" x="-1445" y="-1606">prob_success</label>
			<nail x="-1453" y="-1538"/>
		</transition>
		<transition>
			<source ref="id40"/>
			<target ref="id42"/>
			<label kind="guard" x="-1605" y="-1658">x &gt;= slot_size[bs][id]/2</label>
		</transition>
		<transition>
			<source ref="id39"/>
			<target ref="id33"/>
			<label kind="synchronisation" x="-1826" y="-1701">disconnected[id]!</label>
			<label kind="assignment" x="-1827" y="-1683">z = 0,
x = 0</label>
			<nail x="-1834" y="-1682"/>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id37"/>
			<label kind="synchronisation" x="-1802" y="-1496">listen[id]?</label>
			<label kind="assignment" x="-1802" y="-1479">x = 0,
bs = getBS(id),
channel = broadcast_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id41"/>
			<label kind="guard" x="-1190" y="-1564">!retransmission[bs]</label>
			<label kind="assignment" x="-1190" y="-1547">channel = broadcast_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id35"/>
			<target ref="id40"/>
			<label kind="guard" x="-1410" y="-1683">frame_clk &gt;= slot_start[bs][id]</label>
			<label kind="assignment" x="-1410" y="-1666">x = 0</label>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id37"/>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id34"/>
			<label kind="guard" x="-1513" y="-1496">x &lt;= getLatency(id)</label>
			<label kind="synchronisation" x="-1513" y="-1513">BCH[channel]?</label>
			<label kind="assignment" x="-1513" y="-1479">z = 0</label>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="-1623" y="-1402">failed[id]!</label>
			<label kind="assignment" x="-1623" y="-1385">z = x</label>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id36"/>
			<label kind="guard" x="-1504" y="-1428">x &gt;= getLatency(id)</label>
			<nail x="-1513" y="-1436"/>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id39"/>
			<label kind="guard" x="-1768" y="-1615">z &gt;= disconnect_timeout</label>
		</transition>
	</template>
	<template>
		<name>UserJoined</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int qca_latency = 50;    // QCA processing time (in us)

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // general utility timer

int prob_success;
int prob_failure;

int bs;    // BS that this UE is connected to
int channel;    // BS DL channel

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_failure = channel_interference_probability[id][0];
    prob_success = channel_interference_probability[id][1];
}

// --------------------------------------------------------------------------------------------
// TODO
// What exactly is QCA processing and when does it happen?
// --------------------------------------------------------------------------------------------
</declaration>
		<location id="id43" x="246" y="509">
			<name x="170" y="501">STREAM</name>
		</location>
		<location id="id44" x="246" y="306">
			<urgent/>
		</location>
		<location id="id45" x="60" y="306" color="#ffffff">
			<name x="42" y="255">INITIAL</name>
			<label kind="invariant" x="42" y="272">x' == 0</label>
		</location>
		<location id="id46" x="909" y="238" color="#138d75">
			<name x="884" y="255">BCH_ACK</name>
			<urgent/>
		</location>
		<location id="id47" x="909" y="127" color="#ffa500">
			<name x="867" y="76">WAIT_SLOT</name>
			<label kind="invariant" x="833" y="93">x &lt;= slot_start[bs][id]</label>
		</location>
		<location id="id48" x="484" y="238" color="#ffa500">
			<name x="493" y="246">WAIT_BCH</name>
			<label kind="invariant" x="493" y="263">x &lt;= disconnect_timeout</label>
		</location>
		<location id="id49" x="484" y="475" color="#4e342e">
			<name x="501" y="450">DISCONNECT</name>
			<urgent/>
		</location>
		<location id="id50" x="688" y="127" color="#6c3483">
			<name x="654" y="76">TRANSMIT</name>
			<label kind="invariant" x="629" y="93">x &lt;= slot_size[bs][id]/2</label>
		</location>
		<location id="id51" x="306" y="391">
			<name x="255" y="399">LISTEN</name>
		</location>
		<location id="id52" x="246" y="238">
			<name x="221" y="204">JOINED</name>
			<urgent/>
		</location>
		<location id="id53" x="909" y="178" color="#ff00ff">
			<name x="824" y="169">PREPARE</name>
			<label kind="invariant" x="782" y="187">x &lt;= qca_latency</label>
		</location>
		<location id="id54" x="484" y="357" color="#0000ff">
			<name x="501" y="348">BCH_NACK</name>
			<urgent/>
		</location>
		<branchpoint id="id55" x="484" y="127">
		</branchpoint>
		<init ref="id45"/>
		<transition>
			<source ref="id54"/>
			<target ref="id49"/>
			<label kind="synchronisation" x="493" y="408">disconnected[id]!</label>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id53"/>
			<label kind="guard" x="960" y="238">retransmission[bs]</label>
			<label kind="assignment" x="960" y="255">channel = retransmission_channel[bs]</label>
			<nail x="1071" y="238"/>
			<nail x="1071" y="178"/>
		</transition>
		<transition>
			<source ref="id53"/>
			<target ref="id47"/>
			<label kind="guard" x="926" y="144">x &gt;= qca_latency</label>
		</transition>
		<transition>
			<source ref="id52"/>
			<target ref="id48"/>
			<label kind="assignment" x="340" y="221">x = 0</label>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id52"/>
			<label kind="guard" x="127" y="263">profile[id] == initial</label>
		</transition>
		<transition>
			<source ref="id51"/>
			<target ref="id49"/>
			<label kind="synchronisation" x="323" y="458">disconnected[id]?</label>
			<nail x="306" y="475"/>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id51"/>
			<label kind="guard" x="314" y="306">profile[id] == Listen_Only ||
profile[id] == sRTa</label>
			<label kind="synchronisation" x="314" y="348">listen[id]!</label>
			<nail x="306" y="306"/>
		</transition>
		<transition>
			<source ref="id43"/>
			<target ref="id49"/>
			<label kind="synchronisation" x="263" y="492">disconnected[id]?</label>
			<nail x="484" y="509"/>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id43"/>
			<label kind="guard" x="110" y="390">profile[id] == RTa ||
profile[id] == HqRTa</label>
			<label kind="synchronisation" x="170" y="424">stream[id]!</label>
		</transition>
		<transition>
			<source ref="id55"/>
			<target ref="id48"/>
			<label kind="synchronisation" x="493" y="178">UCCH[bs][id]!</label>
			<label kind="assignment" x="493" y="195">x = 0</label>
			<label kind="probability" x="493" y="161">prob_success</label>
		</transition>
		<transition>
			<source ref="id50"/>
			<target ref="id55"/>
			<label kind="guard" x="510" y="127">x &gt;= slot_size[bs][id]/2</label>
		</transition>
		<transition>
			<source ref="id49"/>
			<target ref="id45"/>
			<label kind="assignment" x="68" y="509">x = 0</label>
			<nail x="510" y="475"/>
			<nail x="510" y="526"/>
			<nail x="59" y="526"/>
		</transition>
		<transition>
			<source ref="id45"/>
			<target ref="id44"/>
			<label kind="synchronisation" x="93" y="305">connected[id]?</label>
			<label kind="assignment" x="93" y="323">x = 0,
bs = getBS(id),
channel = broadcast_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id50"/>
			<label kind="guard" x="731" y="127">x &gt;= slot_start[bs][id]</label>
			<label kind="assignment" x="731" y="144">x = 0</label>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id46"/>
			<label kind="synchronisation" x="637" y="212">BCH[channel]?</label>
			<label kind="assignment" x="637" y="238">x = 0</label>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id54"/>
			<label kind="guard" x="493" y="306">x &gt;= disconnect_timeout</label>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id53"/>
			<label kind="guard" x="918" y="195">!retransmission[bs]</label>
			<label kind="assignment" x="918" y="212">channel = broadcast_channel[bs]</label>
		</transition>
	</template>
	<template>
		<name>UserStates</name>
		<parameter>int id, int start_offset</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock offset;    // start offset timer

int mode = 0;    // 1 - Listen Only, 2 - Streaming

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int getOffset()
{
    if(start_offset == -1) {
        setOffset();
        return start_offsets[id];
    }
    else
    {
        return start_offset;
    }
    return 0;
}</declaration>
		<location id="id56" x="-15130" y="-15266" color="#ffffff">
			<name x="-15147" y="-15317">INIT</name>
			<label kind="invariant" x="-15147" y="-15300">offset' == 1</label>
			<urgent/>
		</location>
		<location id="id57" x="-15130" y="-14882">
			<name x="-15240" y="-14883">LISTEN_ONLY</name>
		</location>
		<location id="id58" x="-14832" y="-14882">
			<name x="-14815" y="-14891">STREAMING</name>
		</location>
		<location id="id59" x="-14985" y="-14968" color="#4e342e">
			<name x="-15011" y="-15002">FAILED</name>
			<urgent/>
		</location>
		<location id="id60" x="-14832" y="-15266" color="#4e342e">
			<name x="-14815" y="-15275">DISCONNECTED</name>
			<urgent/>
		</location>
		<location id="id61" x="-15130" y="-15096">
			<name x="-15249" y="-15113">CONNECTING</name>
			<label kind="invariant" x="-15223" y="-15096">offset' == 0</label>
		</location>
		<location id="id62" x="-15130" y="-15189">
			<name x="-15172" y="-15198">ON</name>
			<label kind="invariant" x="-15113" y="-15198">offset &lt;= start_offset</label>
		</location>
		<location id="id63" x="-15130" y="-15019">
			<name x="-15198" y="-15036">JOINED</name>
		</location>
		<init ref="id56"/>
		<transition>
			<source ref="id63"/>
			<target ref="id58"/>
			<label kind="synchronisation" x="-14934" y="-15045">stream[id]?</label>
			<nail x="-14866" y="-15019"/>
		</transition>
		<transition>
			<source ref="id63"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-14977" y="-15079">disconnected[id]?</label>
			<nail x="-15104" y="-15053"/>
			<nail x="-14866" y="-15053"/>
		</transition>
		<transition>
			<source ref="id63"/>
			<target ref="id57"/>
			<label kind="synchronisation" x="-15198" y="-14968">listen[id]?</label>
			<label kind="assignment" x="-15198" y="-14951">mode = 1</label>
		</transition>
		<transition>
			<source ref="id62"/>
			<target ref="id61"/>
			<label kind="guard" x="-15121" y="-15155">offset &gt;= start_offset</label>
			<label kind="synchronisation" x="-15121" y="-15138">started[id]!</label>
		</transition>
		<transition>
			<source ref="id61"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-14985" y="-15121">disconnected[id]?</label>
			<nail x="-14875" y="-15096"/>
		</transition>
		<transition>
			<source ref="id61"/>
			<target ref="id63"/>
			<label kind="synchronisation" x="-15232" y="-15070">connected[id]?</label>
		</transition>
		<transition>
			<source ref="id59"/>
			<target ref="id57"/>
			<label kind="guard" x="-15096" y="-14934">mode == 1</label>
			<nail x="-15028" y="-14917"/>
			<nail x="-15104" y="-14917"/>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-15266" y="-15342">disconnected[id]?</label>
			<nail x="-15266" y="-14883"/>
			<nail x="-15266" y="-15316"/>
			<nail x="-14832" y="-15316"/>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id56"/>
		</transition>
		<transition>
			<source ref="id58"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-14824" y="-15079">disconnected[id]?</label>
		</transition>
		<transition>
			<source ref="id59"/>
			<target ref="id58"/>
			<label kind="guard" x="-14943" y="-14934">mode == 2</label>
			<nail x="-14951" y="-14917"/>
			<nail x="-14866" y="-14917"/>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id59"/>
			<label kind="synchronisation" x="-15087" y="-14985">failed[id]?</label>
			<nail x="-15104" y="-14968"/>
		</transition>
		<transition>
			<source ref="id58"/>
			<target ref="id59"/>
			<label kind="synchronisation" x="-14926" y="-14985">failed[id]?</label>
			<nail x="-14858" y="-14968"/>
		</transition>
		<transition>
			<source ref="id58"/>
			<target ref="id57"/>
			<label kind="synchronisation" x="-15036" y="-14849">stop_sample[id]?</label>
			<nail x="-14832" y="-14832"/>
			<nail x="-15130" y="-14832"/>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id58"/>
			<label kind="synchronisation" x="-15028" y="-14900">stream[id]?</label>
			<label kind="assignment" x="-15028" y="-14883">mode = 2</label>
		</transition>
		<transition>
			<source ref="id56"/>
			<target ref="id62"/>
			<label kind="assignment" x="-15121" y="-15257">offset = 0,
start_offset = getOffset()</label>
		</transition>
	</template>
	<template>
		<name>UserStream</name>
		<parameter>int id, int dma_latency</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int qca_latency = 50;    // QCA processing time (in us)

const int uart_speed = 1000;    // uart transmission speed (in kbit/s)

const int codec_latency = 1/(44000 * 1000000);

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // DMA delay timer
clock y;    // general usage timer
clock z;    // disconnect timer

BSid_t bs;    // BS that this UE is connected to
int channel;    // BS DL channel

int uart_latency = 0;

bool transmitted;

int prob_success;
int prob_failure;

// packet preparation time: QCA + DMA latencies
// can use samples prepared from last successful transmission to (slot start time - preparation time)

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_success = channel_interference_probability[id][0];
    prob_failure = channel_interference_probability[id][1];
}

void isTransmitted()
{
    if(retransmission[bs] &amp;&amp; !transmitted)
    {
        samples_lost[id] += samples_ready[id];
    }
}

int getUARTTime()
{
    return getULAudioData(id)/(uart_speed/1000);
}

// --------------------------------------------------------------------------------------------
// TODO
// Does all sampling happen and finish before we get data from the BCH and decode it using the
// same DSP chip?
// But it is impossible as sampling happens during the whole frame length..
// --------------------------------------------------------------------------------------------</declaration>
		<location id="id64" x="-1139" y="-1020" color="#ffffff">
			<name x="-1164" y="-1096">INITIAL</name>
			<label kind="invariant" x="-1164" y="-1079">x' == 0 &amp;&amp;
y' == 0</label>
		</location>
		<location id="id65" x="-1300" y="-799" color="#4e342e">
			<name x="-1368" y="-808">FAILED</name>
			<urgent/>
		</location>
		<location id="id66" x="-1299" y="-1020" color="#4e342e">
			<name x="-1342" y="-1054">DISCONNECT</name>
			<urgent/>
		</location>
		<location id="id67" x="-807" y="-918" color="#ff00ff">
			<name x="-884" y="-952">PREPARE</name>
			<urgent/>
		</location>
		<location id="id68" x="-399" y="-994" color="#ffa500">
			<name x="-450" y="-1028">WAIT_SAMPLES</name>
		</location>
		<location id="id69" x="-773" y="-654" color="#6c3483">
			<name x="-833" y="-722">TRANSMIT</name>
			<label kind="invariant" x="-833" y="-705">x' == 1 &amp;&amp;
x &lt;= slot_size[bs][id]/2</label>
		</location>
		<location id="id70" x="-807" y="-799" color="#138d75">
			<name x="-884" y="-841">BCH_ACK</name>
			<label kind="invariant" x="-858" y="-824">y' == 0</label>
			<urgent/>
		</location>
		<location id="id71" x="-399" y="-731">
			<name x="-382" y="-748">PROCESS_QCA</name>
			<label kind="invariant" x="-382" y="-731">x &lt;= qca_latency</label>
		</location>
		<location id="id72" x="-1300" y="-935" color="#3498db">
			<name x="-1393" y="-952">BCH_NACK</name>
			<label kind="invariant" x="-1393" y="-935">y' == 1</label>
			<urgent/>
		</location>
		<location id="id73" x="-510" y="-799" color="#ffff00">
			<name x="-552" y="-833">RETRANSMIT</name>
			<urgent/>
		</location>
		<location id="id74" x="-399" y="-816">
			<name x="-382" y="-833">TRANSFER</name>
			<label kind="invariant" x="-382" y="-817">x &lt;= uart_latency</label>
			<label kind="comments" x="-246" y="-825">DSP to QCA</label>
		</location>
		<location id="id75" x="-399" y="-654" color="#ffa500">
			<name x="-382" y="-671">WAIT_SLOT</name>
			<label kind="invariant" x="-382" y="-654">x' == 0 &amp;&amp;
frame_clk &lt;= slot_start[bs][id]</label>
		</location>
		<location id="id76" x="-986" y="-1020">
			<urgent/>
		</location>
		<location id="id77" x="-986" y="-799" color="#ffa500">
			<name x="-1071" y="-824">WAIT_BCH</name>
		</location>
		<location id="id78" x="-399" y="-918">
			<name x="-382" y="-935">PROCESS_CODEC</name>
			<label kind="invariant" x="-382" y="-918">x &lt;= codec_latency</label>
		</location>
		<location id="id79" x="-1147" y="-654">
			<urgent/>
		</location>
		<branchpoint id="id80" x="-986" y="-654">
		</branchpoint>
		<init ref="id64"/>
		<transition>
			<source ref="id79"/>
			<target ref="id77"/>
			<label kind="guard" x="-1275" y="-705">!retransmission[bs]</label>
			<nail x="-1147" y="-714"/>
		</transition>
		<transition>
			<source ref="id79"/>
			<target ref="id65"/>
			<label kind="guard" x="-1300" y="-654">retransmission[bs] &amp;&amp;
!transmitted</label>
			<nail x="-1300" y="-654"/>
		</transition>
		<transition>
			<source ref="id80"/>
			<target ref="id79"/>
			<label kind="probability" x="-1105" y="-654">prob_failure</label>
		</transition>
		<transition>
			<source ref="id78"/>
			<target ref="id74"/>
			<label kind="guard" x="-391" y="-892">x &gt;= codec_latency</label>
			<label kind="assignment" x="-391" y="-875">x = 0,
uart_latency = getUARTTime()</label>
		</transition>
		<transition>
			<source ref="id68"/>
			<target ref="id78"/>
			<label kind="synchronisation" x="-391" y="-977">sample_ready[id]?</label>
			<label kind="assignment" x="-391" y="-960">x = 0</label>
		</transition>
		<transition>
			<source ref="id67"/>
			<target ref="id78"/>
			<label kind="guard" x="-756" y="-952">samples_ready[id] != 0</label>
			<label kind="assignment" x="-756" y="-935">x = 0</label>
		</transition>
		<transition>
			<source ref="id70"/>
			<target ref="id67"/>
			<label kind="guard" x="-935" y="-867">!retransmission[bs]</label>
			<label kind="assignment" x="-935" y="-884">channel = broadcast_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id77"/>
			<target ref="id70"/>
			<label kind="synchronisation" x="-969" y="-799">BCH[channel]?</label>
			<label kind="assignment" x="-969" y="-782">transmitted = 0</label>
		</transition>
		<transition>
			<source ref="id75"/>
			<target ref="id69"/>
			<label kind="guard" x="-748" y="-654">frame_clk &gt;= slot_start[bs][id]</label>
			<label kind="assignment" x="-748" y="-637">x = 0</label>
		</transition>
		<transition>
			<source ref="id76"/>
			<target ref="id77"/>
			<label kind="synchronisation" x="-977" y="-994">sample[id]!</label>
		</transition>
		<transition>
			<source ref="id74"/>
			<target ref="id71"/>
			<label kind="guard" x="-391" y="-790">x &gt;= uart_latency</label>
			<label kind="assignment" x="-391" y="-773">x = 0</label>
		</transition>
		<transition>
			<source ref="id80"/>
			<target ref="id77"/>
			<label kind="synchronisation" x="-977" y="-713">UTCH[bs][id]!</label>
			<label kind="assignment" x="-977" y="-697">transmitted = 1</label>
			<label kind="probability" x="-977" y="-730">prob_success</label>
		</transition>
		<transition>
			<source ref="id73"/>
			<target ref="id71"/>
			<label kind="assignment" x="-493" y="-799">x = 0</label>
			<nail x="-433" y="-799"/>
		</transition>
		<transition>
			<source ref="id72"/>
			<target ref="id65"/>
			<label kind="guard" x="-1453" y="-875">z &lt; disconnect_timeout</label>
		</transition>
		<transition>
			<source ref="id70"/>
			<target ref="id73"/>
			<label kind="guard" x="-790" y="-824">retransmission[bs]</label>
			<label kind="assignment" x="-790" y="-799">channel = retransmission_channel[bs]</label>
		</transition>
		<transition>
			<source ref="id69"/>
			<target ref="id80"/>
			<label kind="guard" x="-960" y="-654">x &gt;= slot_size[bs][id]/2</label>
			<label kind="assignment" x="-960" y="-637">x = 0,
getProbability()</label>
		</transition>
		<transition>
			<source ref="id71"/>
			<target ref="id75"/>
			<label kind="guard" x="-391" y="-714">x &gt;= qca_latency</label>
			<label kind="assignment" x="-391" y="-697">x = 0</label>
		</transition>
		<transition>
			<source ref="id67"/>
			<target ref="id68"/>
			<label kind="guard" x="-765" y="-1019">samples_ready[id] == 0</label>
			<nail x="-807" y="-994"/>
		</transition>
		<transition>
			<source ref="id66"/>
			<target ref="id64"/>
			<label kind="synchronisation" x="-1275" y="-1020">disconnected[id]!</label>
		</transition>
		<transition>
			<source ref="id72"/>
			<target ref="id66"/>
			<label kind="guard" x="-1461" y="-986">y &gt;= disconnect_timeout</label>
			<label kind="assignment" x="-1342" y="-1003">y = 0</label>
		</transition>
		<transition>
			<source ref="id65"/>
			<target ref="id77"/>
			<label kind="synchronisation" x="-1266" y="-824">failed[id]!</label>
			<label kind="assignment" x="-1266" y="-799">y = 0,
samples_lost[id] = samples_ready[id]</label>
		</transition>
		<transition>
			<source ref="id77"/>
			<target ref="id72"/>
			<label kind="guard" x="-1215" y="-960">x &gt; getLatency(id)</label>
			<label kind="assignment" x="-1215" y="-935">y = x</label>
			<nail x="-1020" y="-935"/>
		</transition>
		<transition>
			<source ref="id64"/>
			<target ref="id76"/>
			<label kind="synchronisation" x="-1088" y="-1020">stream[id]?</label>
			<label kind="assignment" x="-1088" y="-1071">bs = getBS(id),
channel = broadcast_channel[bs]</label>
		</transition>
	</template>
	<template>
		<name>UserConnect</name>
		<parameter>int id</parameter>
		<declaration>// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

const int scan_timeout = 5000;    // time to scan a channel (in us)

const int channel_stability_latency = 100 * unit;    // time to test channel stability before connecting to the BS (in us)

const int number_retries = 10;    // number of allowed retries of channel scanning before going to the INITIAL state

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // general usage timer

int i = 0;    // channel scan counter
int j = 0;    // re-try scan counter

BSid_t bs;    // BS that this UE is connected to
int channel;    // BS DL channel

int prob_stable;
int prob_unstable;

int prob_success;
int prob_failure;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

void getProbability()
{
    prob_unstable = connection_channel_stability[id][0];
    prob_stable = connection_channel_stability[id][1];

    prob_success = channel_interference_probability[id][0];
    prob_failure = channel_interference_probability[id][1];
}

bool checkChannel(int ch_id)
{
    for(k: BSid_t)
    {
        if(broadcast_channel[k] == ch_id)
        {
            BS_assignment[id] = k;
            bs = k;
            channel = ch_id;
            return true;
        }
        if(retransmission_channel[k] == ch_id)
        {
            BS_assignment[id] = k;
            bs = k;
            channel = ch_id;
            return true;
        }
    }
    return false;
}

// --------------------------------------------------------------------------------------------
// TODO
// Channel stability should be dependent on the system topology - distance from the UE to the BS
// --------------------------------------------------------------------------------------------

</declaration>
		<location id="id81" x="-3238" y="-3128" color="#ffffff">
			<name x="-3255" y="-3162">INITIAL</name>
		</location>
		<location id="id82" x="-3238" y="-2805">
			<name x="-3221" y="-2822">TEST_CHANNEL</name>
			<label kind="invariant" x="-3221" y="-2805">x &lt;= channel_stability_latency</label>
		</location>
		<location id="id83" x="-3238" y="-3000">
			<urgent/>
		</location>
		<location id="id84" x="-2754" y="-3128">
			<name x="-2788" y="-3161">CONNECTED</name>
			<urgent/>
		</location>
		<location id="id85" x="-2957" y="-2678" color="#ffa500">
			<name x="-3000" y="-2729">WAIT_BCH</name>
			<label kind="invariant" x="-3034" y="-2712">x &lt;= disconnect_timeout</label>
		</location>
		<location id="id86" x="-2958" y="-2473" color="#6c3483">
			<name x="-2993" y="-2456">TRANSMIT</name>
			<label kind="invariant" x="-2992" y="-2439">x &lt;= RACH_size/2</label>
		</location>
		<location id="id87" x="-2753" y="-2678" color="#138d75">
			<name x="-2737" y="-2694">BCH_ACK</name>
			<urgent/>
		</location>
		<location id="id88" x="-2754" y="-2473" color="#00ffff">
			<name x="-2738" y="-2490">UL_NACK</name>
			<label kind="invariant" x="-2738" y="-2473">frame_clk &lt;= RACH_start</label>
		</location>
		<location id="id89" x="-3238" y="-2941">
			<name x="-3289" y="-2932">SCAN</name>
			<label kind="invariant" x="-3357" y="-2915">x &lt;= scan_timeout</label>
		</location>
		<location id="id90" x="-2754" y="-2907" color="#00ff00">
			<name x="-2737" y="-2915">UL_ACK</name>
			<urgent/>
		</location>
		<location id="id91" x="-2958" y="-3094" color="#4e342e">
			<name x="-2941" y="-3102">DISCONNECT</name>
			<urgent/>
		</location>
		<branchpoint id="id92" x="-2958" y="-2575">
		</branchpoint>
		<branchpoint id="id93" x="-3238" y="-2678">
		</branchpoint>
		<init ref="id81"/>
		<transition>
			<source ref="id92"/>
			<target ref="id85"/>
			<label kind="assignment" x="-2949" y="-2626">RACH_id = id</label>
			<label kind="probability" x="-2949" y="-2643">prob_success</label>
		</transition>
		<transition>
			<source ref="id91"/>
			<target ref="id81"/>
			<label kind="synchronisation" x="-3136" y="-3111">disconnected[id]!</label>
			<nail x="-3204" y="-3094"/>
		</transition>
		<transition>
			<source ref="id90"/>
			<target ref="id84"/>
		</transition>
		<transition>
			<source ref="id83"/>
			<target ref="id89"/>
			<label kind="assignment" x="-3230" y="-2983">x = 0</label>
		</transition>
		<transition>
			<source ref="id86"/>
			<target ref="id85"/>
			<label kind="guard" x="-3153" y="-2524">x &gt;= RACH_size ||
RACH_id != -1</label>
			<label kind="assignment" x="-3153" y="-2490">x = 0</label>
			<nail x="-3018" y="-2473"/>
			<nail x="-3017" y="-2635"/>
		</transition>
		<transition>
			<source ref="id88"/>
			<target ref="id86"/>
			<label kind="guard" x="-2925" y="-2473">frame_clk &gt;= RACH_start</label>
			<label kind="assignment" x="-2797" y="-2456">x = 0</label>
		</transition>
		<transition>
			<source ref="id85"/>
			<target ref="id87"/>
			<label kind="guard" x="-2932" y="-2678">x &lt;= disconnect_timeout</label>
			<label kind="synchronisation" x="-2881" y="-2703">BCH[channel]?</label>
			<nail x="-2949" y="-2678"/>
		</transition>
		<transition>
			<source ref="id85"/>
			<target ref="id91"/>
			<label kind="guard" x="-2949" y="-2898">x &gt;= disconnect_timeout</label>
		</transition>
		<transition>
			<source ref="id87"/>
			<target ref="id90"/>
			<label kind="guard" x="-2745" y="-2805">ACK[id] == 1</label>
		</transition>
		<transition>
			<source ref="id86"/>
			<target ref="id92"/>
			<label kind="guard" x="-2949" y="-2575">x &gt;= RACH_size/2 &amp;&amp;
RACH_id == -1</label>
			<label kind="synchronisation" x="-2949" y="-2541">RACH[bs]!</label>
			<label kind="assignment" x="-2950" y="-2524">x = 0</label>
			<nail x="-2958" y="-2558"/>
		</transition>
		<transition>
			<source ref="id87"/>
			<target ref="id88"/>
			<label kind="guard" x="-2745" y="-2567">ACK[id] == 0</label>
		</transition>
		<transition>
			<source ref="id84"/>
			<target ref="id81"/>
			<label kind="synchronisation" x="-2890" y="-3153">connected[id]!</label>
		</transition>
		<transition>
			<source ref="id89"/>
			<target ref="id83"/>
			<label kind="guard" x="-3451" y="-3000">x &gt;= scan_timeout &amp;&amp;
i &gt;= number_channels &amp;&amp;
j &lt; number_retries</label>
			<label kind="assignment" x="-3451" y="-2941">i = 0,
j++</label>
			<nail x="-3459" y="-2941"/>
			<nail x="-3459" y="-3000"/>
		</transition>
		<transition>
			<source ref="id83"/>
			<target ref="id81"/>
			<label kind="guard" x="-3425" y="-3128">j &gt;= number_retries</label>
			<label kind="synchronisation" x="-3408" y="-3111">disconnected[id]!</label>
			<label kind="assignment" x="-3340" y="-3094">i = 0,
j = 0</label>
			<nail x="-3298" y="-3026"/>
			<nail x="-3298" y="-3128"/>
		</transition>
		<transition>
			<source ref="id89"/>
			<target ref="id83"/>
			<label kind="guard" x="-3051" y="-2992">x &gt;= scan_timeout &amp;&amp;
i &lt; number_channels</label>
			<label kind="assignment" x="-3051" y="-2958">i++</label>
			<nail x="-3060" y="-2941"/>
			<nail x="-3059" y="-3000"/>
		</transition>
		<transition>
			<source ref="id89"/>
			<target ref="id82"/>
			<label kind="guard" x="-3230" y="-2915">i &lt; number_channels</label>
			<label kind="synchronisation" x="-3230" y="-2898">BCH[i]?</label>
			<label kind="assignment" x="-3230" y="-2881">x = 0,
checkChannel(i)</label>
		</transition>
		<transition>
			<source ref="id93"/>
			<target ref="id85"/>
			<label kind="assignment" x="-3162" y="-2677">i = 0,
j = 0,
x = 0</label>
			<label kind="probability" x="-3162" y="-2703">prob_stable</label>
		</transition>
		<transition>
			<source ref="id82"/>
			<target ref="id93"/>
			<label kind="guard" x="-3230" y="-2762">x &gt;= channel_stability_latency</label>
			<label kind="assignment" x="-3230" y="-2745">getProbability()</label>
		</transition>
		<transition>
			<source ref="id81"/>
			<target ref="id83"/>
			<label kind="synchronisation" x="-3230" y="-3085">started[id]?</label>
			<label kind="assignment" x="-3230" y="-3068">i = 0,
j = 0</label>
		</transition>
	</template>
	<template>
		<name>UserSample</name>
		<parameter>int id, double audio_quality, double bit_depth</parameter>
		<declaration>// id: UE identification number
// audio_quality: audio sampling rate (kHz or kb/s)
// bit_depth: bits per sample

// --------------------------------------------------------------------------------------------
// CONSTANTS
// --------------------------------------------------------------------------------------------

// --------------------------------------------------------------------------------------------
// VARIABLES
// --------------------------------------------------------------------------------------------

clock x;    // sampling timer
clock y;    // single sample timer

BSid_t bs;

int codec_latency = 10;    // codec processing delay, depends on MCS

int uart_latency = 1;    // UART connection speed between DSP and QCA (Mbits/s)

int samples;

// --------------------------------------------------------------------------------------------
// FUNCTIONS
// --------------------------------------------------------------------------------------------

int getSampleTime()
{
    // if audio quality is in bit rate (kbps)
    double sample_rate = audio_quality/bit_depth;    // kHz = 1000 * samples/s
    // if audio quality is in sample rate (kHz)
    double time_per_sample = 1/(sample_rate * 1000 * 1000 * unit);    // us * unit
    int result = fint(time_per_sample);
    return result;
}

int getNumberSamples()
{
    int time = getSampleTime();
    return fint(frame_size[bs]/time);
}</declaration>
		<location id="id94" x="-696" y="-654">
			<name x="-765" y="-697">SAMPLE</name>
			<label kind="invariant" x="-748" y="-680">x' == 0</label>
		</location>
		<location id="id95" x="-416" y="-654">
			<name x="-459" y="-637">PROCESS_CODEC</name>
			<label kind="invariant" x="-459" y="-620">x' == 1 &amp;&amp;
x &lt;= codec_latency</label>
		</location>
		<location id="id96" x="-952" y="-654" color="#ffffff">
			<name x="-978" y="-688">INITIAL</name>
		</location>
		<location id="id97" x="-416" y="-756">
			<name x="-458" y="-807">TRANSFER</name>
			<label kind="invariant" x="-467" y="-790">x &lt;= uart_latency</label>
			<label kind="comments" x="-459" y="-833">DSP to QCA</label>
		</location>
		<location id="id98" x="-952" y="-586" color="#4e342e">
			<name x="-1012" y="-595">STOP</name>
			<label kind="testcodeEnter">Add brown color</label>
			<urgent/>
		</location>
		<init ref="id96"/>
		<transition>
			<source ref="id94"/>
			<target ref="id95"/>
			<label kind="synchronisation" x="-603" y="-680">frame_start[bs]?</label>
			<label kind="assignment" x="-603" y="-654">x = 0</label>
		</transition>
		<transition>
			<source ref="id94"/>
			<target ref="id98"/>
			<label kind="synchronisation" x="-867" y="-578">disconnected[id]?</label>
			<nail x="-756" y="-552"/>
			<nail x="-901" y="-552"/>
		</transition>
		<transition>
			<source ref="id94"/>
			<target ref="id98"/>
			<label kind="synchronisation" x="-858" y="-612">stop_sample[id]?</label>
			<nail x="-756" y="-586"/>
		</transition>
		<transition>
			<source ref="id97"/>
			<target ref="id94"/>
			<label kind="guard" x="-696" y="-807">x &gt;= uart_latency</label>
			<label kind="synchronisation" x="-696" y="-790">sample_ready[id]!</label>
			<label kind="assignment" x="-696" y="-773">x = 0</label>
			<nail x="-696" y="-756"/>
		</transition>
		<transition>
			<source ref="id95"/>
			<target ref="id97"/>
			<label kind="guard" x="-408" y="-722">x &gt;= codec_latency</label>
			<label kind="assignment" x="-408" y="-705">x = 0</label>
		</transition>
		<transition>
			<source ref="id98"/>
			<target ref="id96"/>
			<label kind="assignment" x="-994" y="-629">x = 0</label>
		</transition>
		<transition>
			<source ref="id96"/>
			<target ref="id94"/>
			<label kind="synchronisation" x="-910" y="-688">sample[id]?</label>
			<label kind="assignment" x="-910" y="-671">x = 0,
bs = getBS(id)</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
usr_1 = UserStates(0, 5000);
usr_1c = UserConnect(0);
usr_1j = UserJoined(0);
usr_1lt = UserListenOnly(0);
usr_1s = UserStream(0, 1);
usr_1sm = UserSample(0, 48, 16);

usr_2 = UserStates(1, 0);
usr_2c = UserConnect(1);
usr_2j = UserJoined(1);
usr_2lt = UserListenOnly(1);
usr_2s = UserStream(1, 1);
usr_2sm = UserSample(1, 48, 16);

bs_1 = BaseStation(0);
bs_1s = Scheduler(0);
bs_1dsp = BaseStationDSP(0);

bs_2 = BaseStation(1);
bs_2s = Scheduler(1);
bs_2dsp = BaseStationDSP(1);

// List one or more processes to be composed into a system.
system bs_1, bs_1s, bs_1dsp, bs_2, bs_2s, bs_2dsp, usr_1, usr_1s, usr_1c, usr_1j, usr_1lt, usr_1sm;
    </system>
	<queries>
		<query>
			<formula>A[] not bs_1s.UNSCHEDULABLE</formula>
			<comment>Frame must always be schedulable.</comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.RETRY</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.RETRANSMISSION</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.FINISHED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.STARTED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1s.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.NEXT_SLOT</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] not bs_1.FAILED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] not bs_1.BUSY</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.PROCESS_INTERNAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.TRANSFER</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.PROCESS_QCA</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.UL_NACK</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.UL_ACK</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.WAIT_SLOT</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.WAIT_UL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.GUARD</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.RETRANSMISSION</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.SWITCH_CHANNEL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.TRANSMIT_BCH</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.READY</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.WAIT_READY</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.PREPARE</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.TRANSMISSION</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1dsp.PROCESS_CENTRAL_BASE</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1dsp.DECODE_AUDIO</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1dsp.TRANSFER_AES</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1dsp.PROCESS_INTERNAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; bs_1dsp.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1lt.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.INITIAL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.BCH_ACK</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.WAIT_BCH</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.TEST_CHANNEL</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1c.SCAN</formula>
			<comment></comment>
		</query>
		<query>
			<formula></formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.INIT</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.CONNECTING</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.DISCONNECTED</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A&lt;&gt; usr_1.LISTEN_ONLY</formula>
			<comment></comment>
		</query>
	</queries>
</nta>
